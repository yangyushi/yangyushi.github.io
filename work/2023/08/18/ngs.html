<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>二代测序</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link rel="stylesheet" href="/assets/css/styles/github-gist.css">
    <script src="https://unpkg.com/lunr/lunr.js"></script>

    <script src="/assets/js/toc.js"></script>
    <script src="/assets/js/highlight.pack.js"></script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true
        }
      });
    </script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    </head>

  <body>
    <script>hljs.initHighlightingOnLoad();</script>

    <div class="main">
        <div id="side_bar">
    18 Aug 2023
</div>

<div class="center post">
    <ul id="markdown-toc">
  <li><a href="#测序基础" id="markdown-toc-测序基础">测序基础</a>    <ul>
      <li><a href="#dna-基础" id="markdown-toc-dna-基础">DNA 基础</a></li>
      <li><a href="#pe-测序" id="markdown-toc-pe-测序">PE 测序</a></li>
    </ul>
  </li>
  <li><a href="#barcode" id="markdown-toc-barcode">Barcode</a>    <ul>
      <li><a href="#单端-barcode" id="markdown-toc-单端-barcode">单端 barcode</a></li>
      <li><a href="#双端-barcode" id="markdown-toc-双端-barcode">双端 barcode</a></li>
      <li><a href="#单读段-barcode" id="markdown-toc-单读段-barcode">单读段 barcode</a></li>
    </ul>
  </li>
  <li><a href="#概率模型" id="markdown-toc-概率模型">概率模型</a>    <ul>
      <li><a href="#马尔科夫链" id="markdown-toc-马尔科夫链">马尔科夫链</a></li>
    </ul>
  </li>
</ul>

<h2 id="测序基础">测序基础</h2>

<h3 id="dna-基础">DNA 基础</h3>

<ul>
  <li>DNA 由两条反向互补的链组成，每条链都有一个 5’ 端和一个 3’ 端。</li>
  <li>标准的 DNA 序列方向是从 5’ 到 3’。</li>
</ul>

<h3 id="pe-测序">PE 测序</h3>

<ul>
  <li><strong>PE (Pair Ended) 测序</strong>可以提供片段两端的序列信息。</li>
  <li>这种测序方式可以帮助我们了解片段的方向和距离信息。</li>
</ul>

<p>假设测序的 DNA 片段是：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5' - ATGCACTGACTGAGCTA - 3'
3' - TACGTGACTGACTCGAT - 5'
</code></pre></div></div>

<p>测序结果为：
<strong>读段 1</strong>：<code class="language-plaintext highlighter-rouge">5' - ATGCACTGA - 3'</code>
<strong>读段 2</strong>：<code class="language-plaintext highlighter-rouge">5' - TAGCTCAGT - 3'</code></p>

<p>###</p>

<h2 id="barcode">Barcode</h2>

<p><strong>目的</strong>：在测序中，我们经常一次性测序来自不同样品的多个 DNA 片段。为了在测序完成后能区分各个样品，我们会在每个片段上加上一个独特的 DNA 序列，称为 barcode。测序后，我们可以根据这些 barcode 来拆分、分类数据。</p>

<h3 id="单端-barcode">单端 barcode</h3>

<p>只在片段的一个端（如 5’ 端）加入 barcode。<strong>示例</strong>：</p>

<p>加入 barcode <code class="language-plaintext highlighter-rouge">GGTT</code> 后的片段：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5' - GGTTATGCACTGACTGAGCTA - 3'
3' - AACCTACGTGACTGACTCGAT - 5'
</code></pre></div></div>

<ul>
  <li>测序读段 1：<code class="language-plaintext highlighter-rouge">5' - GGTTATGCA - 3'</code></li>
</ul>

<h3 id="双端-barcode">双端 barcode</h3>

<p>在片段的两端都加入 barcode。<strong>示例</strong>：</p>

<p>5’ 端的 barcode 为 <code class="language-plaintext highlighter-rouge">GGTT</code>，3’ 端的 barcode 为 <code class="language-plaintext highlighter-rouge">AACC</code>。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5' - GGTTATGCACTGACTGAGCTAAACC - 3'
3' - TTGGTACGTGACTGACTCGATGGTT - 5'
</code></pre></div></div>

<ul>
  <li>测序读段 1：<code class="language-plaintext highlighter-rouge">5' - GGTTATGCA - 3'</code></li>
  <li>测序读段 2：<code class="language-plaintext highlighter-rouge">5' - GGTTATCGA - 3'</code></li>
</ul>

<h3 id="单读段-barcode">单读段 barcode</h3>

<p>在 paired-end 测序中，只在一个特定的读段（如 Read1）添加 barcode。<strong>示例</strong>：</p>

<p>在 Read1 上添加 barcode <code class="language-plaintext highlighter-rouge">GGTT</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5' - GGTTATGCACTGACTGAGCTA - 3'
3' - AACCTACGTGACTGACTCGAT - 5'
</code></pre></div></div>

<ul>
  <li>测序读段 1：<code class="language-plaintext highlighter-rouge">5' - GGTTATGCA - 3'</code></li>
</ul>

<h2 id="概率模型">概率模型</h2>

<h3 id="马尔科夫链">马尔科夫链</h3>

<p>通过 Markov Chain 我们可以精确计算出，在观测到 \( n \) 个碱基时，出现 \( m \) 个特定类别（ACGT）的碱基
的概率。下面，我们以碱基类别 A 举例。</p>

<p>我们用一个 \( n+1 \) 维的向量<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>，表示这个概率分布 \( \mathbf{x} \in \mathbb{R}^{n+1} \)。</p>

<ol>
  <li>没有观察任何碱基的时候，系统状态是
 \( \mathbf{x}_0 = [1, 0, …]^\top \)，
表示 A 必然出现 0 次。</li>
  <li>观察 1 个碱基后，我们有 \( p \) 的概率观察到 A，系统状态是
 \( \mathbf{x}_1 = [q, p, 0, …]^\top \)；
其中，\( q = 1 - p \)，表示碱基没有出现的概率。</li>
  <li>当我们观察第 2 个碱基的时候，我们有以概率 \( p \) 多观察到一个 A，系统状态是
\( \mathbf{x}_2 = [qq, pq, pp, 0, …]^\top \)；</li>
</ol>

<p>我们可以把这个过程抽象为一个 Markov Chain，其转移矩阵为，</p>

\[\mathbf{P}_{n \times n} = \begin{bmatrix}
q &amp;   &amp;   &amp;   &amp;   &amp; \dots  &amp;   &amp; \\
p &amp; q &amp;   &amp;   &amp;   &amp; \dots  &amp;   &amp; \\
  &amp; p &amp; q &amp;   &amp;   &amp; \dots  &amp;  &amp; \\
  &amp;   &amp; p &amp; q &amp;   &amp; \dots  &amp;   &amp; \\
  &amp;   &amp;   &amp; \vdots  &amp;  &amp;&amp; &amp; \\
  &amp;   &amp;   &amp;   &amp;   &amp; \dots  &amp; q  &amp;  \\
  &amp;   &amp;   &amp;   &amp;   &amp; \dots  &amp;  p &amp; 1 \\
\end{bmatrix}\]

<p>从初始状态 \( \mathbf{x}_0 \) 开始，我们通过观测 \( n \) 次结果，得到最终的状态 \( \mathbf{x}_n \)，并且</p>

\[\mathbf{x}_n = \left( \mathbf{P}_{n \times n} \right)^n \cdot \mathbf{x}_0\]

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>在这里，\( +1 \) 的原因是因为我们要考虑“出现 0 次”的状况。我们可以轻松地作出下面的断言： <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>


    </div>

  </body>

</html>
