<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>C++</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link rel="stylesheet" href="/assets/css/styles/github-gist.css">
    <script src="https://unpkg.com/lunr/lunr.js"></script>

    <script src="/assets/js/toc.js"></script>
    <script src="/assets/js/highlight.pack.js"></script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true
        }
      });
    </script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    </head>

  <body>
    <script>hljs.initHighlightingOnLoad();</script>

    <div class="main">
        <p><a href="/" id="backToHomeButton">Home</a></p>

<div id="side_bar">
    14 Apr 2021
</div>

<div class="center post">
    <ul id="markdown-toc">
  <li><a href="#迭代技术" id="markdown-toc-迭代技术">迭代技术</a>    <ul>
      <li><a href="#传统循环" id="markdown-toc-传统循环">传统循环</a></li>
      <li><a href="#基于-stl-的迭代" id="markdown-toc-基于-stl-的迭代">基于 STL 的迭代</a></li>
    </ul>
  </li>
  <li><a href="#并发" id="markdown-toc-并发">并发</a>    <ul>
      <li><a href="#c11-并发功能" id="markdown-toc-c11-并发功能">C++11 并发功能</a></li>
      <li><a href="#c17-及以后" id="markdown-toc-c17-及以后">C++17 及以后</a></li>
      <li><a href="#深入原子操作-stdatomic" id="markdown-toc-深入原子操作-stdatomic">深入原子操作 (<code class="language-plaintext highlighter-rouge">std::atomic</code>)</a></li>
    </ul>
  </li>
  <li><a href="#函数" id="markdown-toc-函数">函数</a>    <ul>
      <li><a href="#inline" id="markdown-toc-inline">inline</a></li>
      <li><a href="#在不同源代码中共享函数" id="markdown-toc-在不同源代码中共享函数">在不同源代码中共享函数</a></li>
      <li><a href="#传递指针给函数" id="markdown-toc-传递指针给函数">传递指针给函数</a></li>
      <li><a href="#没有变量名的参数" id="markdown-toc-没有变量名的参数">没有变量名的参数</a></li>
    </ul>
  </li>
  <li><a href="#指针" id="markdown-toc-指针">指针</a>    <ul>
      <li><a href="#基础" id="markdown-toc-基础">基础</a></li>
      <li><a href="#声明指针" id="markdown-toc-声明指针">声明指针</a></li>
      <li><a href="#内存" id="markdown-toc-内存">内存</a></li>
      <li><a href="#指针不知道内存的长度" id="markdown-toc-指针不知道内存的长度">指针不知道内存的长度</a></li>
      <li><a href="#给自定义类型分配内存" id="markdown-toc-给自定义类型分配内存">给自定义类型分配内存</a></li>
      <li><a href="#释放内存" id="markdown-toc-释放内存">释放内存</a></li>
      <li><a href="#null-指针" id="markdown-toc-null-指针">null 指针</a></li>
    </ul>
  </li>
  <li><a href="#结构体" id="markdown-toc-结构体">结构体</a>    <ul>
      <li><a href="#简介" id="markdown-toc-简介">简介</a></li>
      <li><a href="#结构体的指针" id="markdown-toc-结构体的指针">结构体的指针</a></li>
      <li><a href="#结构体和类" id="markdown-toc-结构体和类">结构体和类</a></li>
    </ul>
  </li>
  <li><a href="#类" id="markdown-toc-类">类</a>    <ul>
      <li><a href="#原则" id="markdown-toc-原则">原则</a></li>
      <li><a href="#不同的方法" id="markdown-toc-不同的方法">不同的方法</a></li>
      <li><a href="#一些运算符的读法" id="markdown-toc-一些运算符的读法">一些运算符的「读法」</a></li>
      <li><a href="#构造函数" id="markdown-toc-构造函数">构造函数</a></li>
      <li><a href="#默认构造函数" id="markdown-toc-默认构造函数">默认构造函数</a></li>
      <li><a href="#析构函数" id="markdown-toc-析构函数">析构函数</a></li>
      <li><a href="#生成析构函数" id="markdown-toc-生成析构函数">生成析构函数</a></li>
      <li><a href="#指针-1" id="markdown-toc-指针-1">指针</a></li>
      <li><a href="#运算符重载" id="markdown-toc-运算符重载">运算符重载</a></li>
      <li><a href="#this" id="markdown-toc-this">this</a></li>
      <li><a href="#静态成员-static-member" id="markdown-toc-静态成员-static-member">静态成员 static member</a></li>
      <li><a href="#friend" id="markdown-toc-friend">Friend</a></li>
      <li><a href="#继承" id="markdown-toc-继承">继承</a></li>
      <li><a href="#虚函数" id="markdown-toc-虚函数">虚函数</a></li>
      <li><a href="#const-function" id="markdown-toc-const-function">const function</a></li>
    </ul>
  </li>
  <li><a href="#其他话题" id="markdown-toc-其他话题">其他话题</a>    <ul>
      <li><a href="#头文件里放什么" id="markdown-toc-头文件里放什么">头文件里放什么</a></li>
      <li><a href="#map-的迭代" id="markdown-toc-map-的迭代">map 的迭代</a></li>
      <li><a href="#vim-配置" id="markdown-toc-vim-配置">Vim 配置</a></li>
    </ul>
  </li>
</ul>

<h2 id="迭代技术">迭代技术</h2>

<p>迭代是编程中的基础概念，而 C++ 提供了许多技术来迭代集合，每种技术都有其细微差别和用例。</p>

<h3 id="传统循环">传统循环</h3>

<ol>
  <li><strong>基本的 For 循环</strong>：当迭代次数事先已知时常用。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 访问 vec[i]</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>While 和 Do-While 循环</strong>：当迭代次数不是由索引严格定义，或者循环至少必须运行一次时使用。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// While 循环</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 访问 vec[i]</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Do-While 循环</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="c1">// 访问 vec[j]</span>
    <span class="o">++</span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</code></pre></div>    </div>
  </li>
  <li><strong>基于指针的迭代</strong>：直接访问内存，通常与 C 风格的数组一起使用。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">arr</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 访问 *p</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="基于-stl-的迭代">基于 STL 的迭代</h3>

<ol>
  <li><strong>基于迭代器的 For 循环</strong>：使用容器定义的迭代器直接访问元素。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 访问 *it</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>基于范围的 For 循环</strong>：C++11 引入，用于简化容器遍历。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">value</span> <span class="o">:</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 访问 value</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>使用函数指针和仿函数的 <code class="language-plaintext highlighter-rouge">std::for_each</code></strong>：在 C++11 的 lambda 函数之前，这些是常用的方法。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用函数指针</span>
<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">process</span><span class="p">);</span>

<span class="c1">// 使用仿函数</span>
<span class="k">struct</span> <span class="nc">MyFunctor</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 处理 value</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">MyFunctor</span><span class="p">());</span>
</code></pre></div>    </div>
  </li>
  <li><strong>使用 Lambda 的 <code class="language-plaintext highlighter-rouge">std::for_each</code></strong>：C++11 之后，lambda 函数提供了一种更简洁的使用 <code class="language-plaintext highlighter-rouge">std::for_each</code> 的方式。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 处理 value</span>
<span class="p">});</span>
</code></pre></div>    </div>
  </li>
  <li><strong>带迭代器的算法</strong>：<code class="language-plaintext highlighter-rouge">&lt;algorithm&gt;</code> 中的 STL 算法在迭代器范围上操作。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 示例：std::transform</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="p">});</span>
</code></pre></div>    </div>
  </li>
  <li><strong>并行迭代</strong>：C++17 引入了并行算法，用于多线程处理。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">process</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>虽然传统的循环机制仍然是相关的，尤其是对于更简单的任务或与内存紧密合作时，基于 STL 的技术提供了强大、表现力强和通常更易读的方式来迭代集合。选择技术应由任务的具体要求、所需的代码清晰度和性能考虑来驱动。</p>

<h2 id="并发">并发</h2>

<p>并发涉及设计和构建系统来管理多个任务，这些任务可能重叠或交错。C++ 的发展显著地增加了并发支持功能。</p>

<ul>
  <li><strong>并发</strong>: 针对多个任务的设计中心管理。 It’s more about managing many things at once.</li>
  <li><strong>并行</strong>: 任务执行以提高性能。It’s about doing many things at once.</li>
</ul>

<p>C++11 之前，标准库</p>

<ul>
  <li>缺少内置并发支持。</li>
  <li>依赖于特定平台的库或 <code class="language-plaintext highlighter-rouge">Boost.Thread</code>。</li>
</ul>

<h3 id="c11-并发功能">C++11 并发功能</h3>

<p><strong>内存模型</strong>: 使多线程场景下的内存行为易于理解。</p>

<p><strong>线程 (<code class="language-plaintext highlighter-rouge">&lt;thread&gt;</code>)</strong>: 提供直接、可访问的方法在不同线程中运行函数。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">print_hello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"来自另一个线程的问候！"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">print_hello</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"来自主线程的问候！"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>互斥体 (<code class="language-plaintext highlighter-rouge">&lt;mutex&gt;</code>)</strong>: 保证数据完整性，避免数据竞争。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">shared_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="o">++</span><span class="n">shared_data</span><span class="p">;</span>
        <span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"共享数据值: "</span> <span class="o">&lt;&lt;</span> <span class="n">shared_data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>条件变量 (<code class="language-plaintext highlighter-rouge">&lt;condition_variable&gt;</code>)</strong>: 基于特定条件同步线程。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">ready</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">print_message</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[]{</span> <span class="k">return</span> <span class="n">ready</span><span class="p">;</span> <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"来自工作线程的问候！"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">print_message</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"设置就绪标志..."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
        <span class="n">ready</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>原子操作 (<code class="language-plaintext highlighter-rouge">&lt;atomic&gt;</code>)</strong>: 对共享数据进行无锁操作。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"计数值: "</span> <span class="o">&lt;&lt;</span> <span class="n">count</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>未来 (<code class="language-plaintext highlighter-rouge">&lt;future&gt;</code>)</strong>: 异步运行函数并稍后检索结果。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">compute</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span> <span class="o">*</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">compute</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"执行其他任务..."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"结果: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="c17-及以后">C++17 及以后</h3>

<p><strong>并行算法</strong>: 无需手动线程管理即可获得最佳性能。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>并发 TS 和协程</strong>: 线性、可读的异步代码。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 注意: 实际使用可能需要编译器和标准库对协程的支持。</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;coroutine&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">compute</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">co_return</span> <span class="mi">42</span> <span class="o">*</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">compute</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"结果: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="深入原子操作-stdatomic">深入原子操作 (<code class="language-plaintext highlighter-rouge">std::atomic</code>)</h3>

<p>在多线程程序中，<code class="language-plaintext highlighter-rouge">std::atomic</code> 为变量提供了原子（不可中断）操作，以防止在并发上下文中的数据竞争。</p>

<p><strong>基本原子操作</strong>：<code class="language-plaintext highlighter-rouge">std::atomic</code> 的主要用途是保证对封装的变量进行原子操作。这包括赋值、读取、增加等操作。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">counter</span><span class="o">++</span><span class="p">;</span>       <span class="c1">// 原子增加</span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">counter</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>  <span class="c1">// 原子读取</span>
</code></pre></div></div>

<p>对于非原子变量，我们需要用 mutex 保护它，来达到 thread-safe.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">atomicCount</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nonAtomicCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">process</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">atomicCount</span><span class="p">;</span>

    <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="o">++</span><span class="n">nonAtomicCount</span><span class="p">;</span>
    <span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>内存顺序</strong>：<code class="language-plaintext highlighter-rouge">std::atomic</code> 提供了控制操作的内存顺序的更高级特性。这允许开发者在特定场景中优化线程之间的同步。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">counter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>复杂原子操作</strong>：除基本操作外，<code class="language-plaintext highlighter-rouge">std::atomic</code> 提供了更复杂的原子操作，如 <code class="language-plaintext highlighter-rouge">compare_exchange_weak</code> 和 <code class="language-plaintext highlighter-rouge">compare_exchange_strong</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">expected</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">atomicVar</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>原子标志</strong>：<code class="language-plaintext highlighter-rouge">std::atomic_flag</code> 是一个专门的原子类型，作为一个自旋锁。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">atomic_flag</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">ATOMIC_FLAG_INIT</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">.</span><span class="n">test_and_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span>  <span class="c1">// 自旋直到标志清除</span>
<span class="c1">// 临界区</span>
<span class="n">flag</span><span class="p">.</span><span class="n">clear</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>专门的原子类型</strong>：C++ 标准库为整数、指针和其他常见类型提供了专门的原子类型，如 <code class="language-plaintext highlighter-rouge">std::atomic_int</code>, <code class="language-plaintext highlighter-rouge">std::atomic_long</code>, <code class="language-plaintext highlighter-rouge">std::atomic_bool</code> 和 <code class="language-plaintext highlighter-rouge">std::atomic&lt;void*&gt;</code>。</p>

<p>总之，<code class="language-plaintext highlighter-rouge">std::atomic</code> 不仅仅是改变变量的行为，它提供了丰富的特性，允许开发者创建精密的多线程算法和数据结构。</p>

<h2 id="函数">函数</h2>

<h3 id="inline">inline</h3>

<p>在定义函数的时候，我们可以尝试在 函数前面 加上 <code class="language-plaintext highlighter-rouge">inline</code>。它的作用是把 函数 变成 类似于宏的东西。这样，编译的时候，编译器会直接把 函数部分的代码 复制到 调用函数的地方。</p>

<p><code class="language-plaintext highlighter-rouge">inline</code> 只是一个给编译器的「建议」。对于太长的函数，编译器有可能忽略掉这个建议。</p>

<p>简而言之，对于特别短的函数，<code class="language-plaintext highlighter-rouge">inline</code> 有可能让它更快。</p>

<p><code class="language-plaintext highlighter-rouge">inline</code> 还可以用于「躲避」掉对函数的重复定义。比如说，如果我们在头文件 <code class="language-plaintext highlighter-rouge">*.h</code> 里定义函数，那么 <code class="language-plaintext highlighter-rouge">inline</code> 可以让这个「函数」作为宏被替换进源代码里；这样函数就不会重复定义了。</p>

<h3 id="在不同源代码中共享函数">在不同源代码中共享函数</h3>

<p><a href="https://stackoverflow.com/a/25274411">参考链接</a></p>

<p>如果我们想要在我们的「项目」下的「不同源代码」里共用一个函数，我们可以通过下面的三个步骤完成</p>

<p>1 - 将函数的定义写进「头文件」</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef FUNCTIONS_H_INCLUDED
#define FUNCTIONS_H_INCLUDED
</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// Function prototype, its declaration</span>

<span class="cp">#endif
</span></code></pre></div></div>

<p>（其中的 <code class="language-plaintext highlighter-rouge">#ifndef</code> 之类的东西叫做 <a href="https://en.wikipedia.org/wiki/Include_guard">include gard</a>，用来避免 重复引用头文件 造成的 对同一个函数的 多次定义。注意，include gard 只在「同一个」.cpp 源文件内起作用。）</p>

<p>2 - 在「第一个」源文件里定义函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"functions.h"</span><span class="cp">
</span>
<span class="c1">// Function definition</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>3 - 在「其他源文件」中 <code class="language-plaintext highlighter-rouge">include</code> 头文件，使用函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">"functions.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"add(1, 2) = "</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="传递指针给函数">传递指针给函数</h3>

<p>C 里传递指针式传递「指针」，<code class="language-plaintext highlighter-rouge">* arg</code></p>

<pre><code class="language-C">#include "stdio.h"

void triple(int *num) {
    *num = *num * 3;
}

int main(){
    int a = 2;
    triple(&amp;a);
    printf("2 x 3 = %d", a); // a = 6
}
</code></pre>

<p>C++ 里可以做同样的事情，不过也可以传递「地址」</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">triple</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">triple</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2 x 3 = "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// a = 6</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="没有变量名的参数">没有变量名的参数</h3>

<p>在某些特殊的情况下，我们会写出下面的函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">one</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>这个函数 的输入 是一个小数，输出 永远为 1.0。此时，输入的参数 并不会进入 实际的计算，所以我么不需要给它 变量名。这就是有点怪异的 <code class="language-plaintext highlighter-rouge">one(double)</code> 部分的由来。</p>

<h2 id="指针">指针</h2>

<h3 id="基础">基础</h3>

<ul>
  <li>声明指向类型的指针 <code class="language-plaintext highlighter-rouge">类型 * 指针名</code></li>
  <li>获取指针的内容 (dereference) <code class="language-plaintext highlighter-rouge">* 指针名</code></li>
  <li>我们也可以用 <code class="language-plaintext highlighter-rouge">指针名[位移]</code> 来取得地址的内容，<code class="language-plaintext highlighter-rouge">[]</code> 叫 subscript operator。</li>
  <li><code class="language-plaintext highlighter-rouge">指针名[0]</code> 等价于 <code class="language-plaintext highlighter-rouge">* 指针名</code></li>
  <li>获取一个对象的地址 <code class="language-plaintext highlighter-rouge">&amp; 对象名</code>，<code class="language-plaintext highlighter-rouge">&amp;</code> 叫 address of operator</li>
</ul>

<p>使用 <code class="language-plaintext highlighter-rouge">sizeof</code> 函数可以获取 不同对象/指针 占用的内存，下面是一些结果</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">uint8_t:</span>  <span class="mi">1</span>  <span class="c1">// 数据占用的内存</span>
<span class="kt">double</span><span class="o">:</span>   <span class="mi">8</span>  <span class="c1">// 数据占用的内存</span>
<span class="o">*</span><span class="kt">uint8_t</span><span class="o">:</span> <span class="mi">8</span>  <span class="c1">// 指针占用的内存</span>
<span class="o">*</span><span class="kt">double</span><span class="o">:</span>  <span class="mi">8</span>  <span class="c1">// 指针占用的内存</span>
</code></pre></div></div>

<h3 id="声明指针">声明指针</h3>

<p>我们可以先「给一个变量赋值」，再「得到指向这个变量的指针」</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果我们想要「先创建一个指针」，接着「给指针指向的内存赋值」，直觉上我们会写出这样的代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这段代码一定不会编译成功</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pa</span><span class="p">;</span>  <span class="c1">// 没有初始化，得到一个随机地址；这样的代码永远不应该出现</span>
    <span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的代码首先生成了一个「随机的地址」，之后向这个地址写入了 <code class="language-plaintext highlighter-rouge">1</code>。这样是不对的，因为我们有可能改变程序里其他对象的值。</p>

<p>不过，如果我们主动声明「指针指向的变量」，即确定「指针的地址」，那么我们就可以给这个地址赋值了。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 可以编译成功</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pa</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>还有一种方法是使用 <code class="language-plaintext highlighter-rouge">new</code> 主动分配内存</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// 得到一个 heap 里的随机地址</span>
    <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="内存">内存</h3>

<p>为了更好的理解指针，我们需要理解 C++ 如何使用 电脑中的内存。</p>

<table>
  <thead>
    <tr>
      <th>一段 C++ 代码占用的内存</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Code 代码本身占用的内存</td>
    </tr>
    <tr>
      <td>Static Data 声明的全局变量</td>
    </tr>
    <tr>
      <td>Stack 函数使用的内存（函数的参数、临时变量）</td>
    </tr>
    <tr>
      <td>Free store 其他的内存，也叫 heap</td>
    </tr>
  </tbody>
</table>

<p>如果我们要使用 heap，我们使用关键字 <code class="language-plaintext highlighter-rouge">new</code>，比如</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</code></pre></div></div>

<p>此外，我们可以用「变量」来指定「指针指向的内存」的长度</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">double</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</code></pre></div></div>

<p>此外，我们也可以直接通过 <code class="language-plaintext highlighter-rouge">{}</code> 给指针指向的内存赋值</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</code></pre></div></div>

<h3 id="指针不知道内存的长度">指针不知道内存的长度</h3>

<p><code class="language-plaintext highlighter-rouge">double * p = new double[2]</code> 在 free store (heap) 区域里分配了 2 个 <code class="language-plaintext highlighter-rouge">double</code> 占用的内存，并且返回一个指向这一小块内存的指针 <code class="language-plaintext highlighter-rouge">p</code>。但是，指针<strong>不知道</strong>自己指向的内存的长度。</p>

<p>这意味着，我们可以使用所有 free store / heap 里的内存。这样是不对的，会导致神秘的错误，制造最难查的 bug。这种错误的行为叫 out-of-range access。</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="bp">...</span>
</code></pre></div></div>

<p>避免 out-of-range access 的方法是使用 <code class="language-plaintext highlighter-rouge">vector</code></p>

<h3 id="给自定义类型分配内存">给自定义类型分配内存</h3>

<p>假设我们的自定义类型为 <code class="language-plaintext highlighter-rouge">X</code> 并且<strong>有</strong>默认的构造函数，那么我们可以这样</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">X</span><span class="o">*</span> <span class="n">px1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">X</span><span class="p">;</span>  <span class="c1">// 使用默认构造函数创建一个 X 实例</span>
<span class="n">X</span><span class="o">*</span> <span class="n">px1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">X</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">// 使用默认构造函数创建 10 个 X 实例</span>
</code></pre></div></div>

<p>如果我们的自定义类型为 <code class="language-plaintext highlighter-rouge">Y</code> 并且<strong>没有</strong>默认的构造函数，那么我们可以这样</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Y</span><span class="o">*</span> <span class="n">py1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Y</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>  <span class="c1">// 使用参数 1 初始化 1 个 Y 实例</span>
<span class="n">Y</span><span class="o">*</span> <span class="n">py2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Y</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>  <span class="c1">// 使用参数 1-5 初始化 5 个 Y 实例</span>
</code></pre></div></div>

<h3 id="释放内存">释放内存</h3>

<p>我们需要「手动释放」不需要的指针，来解放这个 指针 对应的 内存。语法如下</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">delete</span> <span class="n">p</span>  <span class="c1">// 释放单个对象占用的内存</span>
<span class="k">delete</span><span class="p">[]</span> <span class="n">p</span>  <span class="c1">// 释放「多个对象组成的数组」所占用的内存</span>
</code></pre></div></div>

<p>我们需要「自行抉择」什么时候、如何释放内存。我们可以使用 garbage collector 来自动帮我们做这件事。如果我们不释放内存，我们的程序会在逐渐运行的时候，消耗掉 所有内存 然后被 操作系统 残忍地杀掉。</p>

<h3 id="null-指针">null 指针</h3>

<p>如果我们在 创建指针的时候 暂时没有一个「用于初始化」的地址，那么我们<strong>应该</strong>用 <code class="language-plaintext highlighter-rouge">nullptr</code> 来 初始化这个指针</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="o">*</span> <span class="n">p0</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
</code></pre></div></div>

<p>这会将 <code class="language-plaintext highlighter-rouge">p0</code> 的地址设定为 <code class="language-plaintext highlighter-rouge">0x0</code>。</p>

<p>此外，不同的编译器 对于 没有初始化的指针 有不同的处理。苹果的 <code class="language-plaintext highlighter-rouge">clang11</code> 会将 没有初始化的指针 自动设置为 <code class="language-plaintext highlighter-rouge">nummptr</code> 但是 <code class="language-plaintext highlighter-rouge">g++9.2</code> 不会。</p>

<p>我们可以用 下面两种方法 判断 指针 是否属于 <code class="language-plaintext highlighter-rouge">nullptr</code>；我们会这么做的原因是，有的时候我们需要 构建一个指针——它在 某种情况下 有效，指向某个地址；在 另外的情况下 无效，指向 <code class="language-plaintext highlighter-rouge">nullptr</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>  <span class="c1">// 第一种</span>
<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// 第二种，推荐</span>
</code></pre></div></div>

<h2 id="结构体">结构体</h2>

<h3 id="简介">简介</h3>

<p>C++ 里最简单的 结构体 用法</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Date</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">month</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">day</span><span class="p">;</span>
<span class="p">}</span> <span class="n">birthdays</span> <span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">birthdays</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">year</span> <span class="o">=</span> <span class="mi">1992</span><span class="p">;</span>
    <span class="n">birthdays</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">month</span> <span class="o">=</span> <span class="s">"feb"</span><span class="p">;</span>
    <span class="n">birthdays</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">day</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
    <span class="n">birthdays</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">year</span> <span class="o">=</span> <span class="mi">1989</span><span class="p">;</span>
    <span class="n">birthdays</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">month</span> <span class="o">=</span> <span class="s">"may"</span><span class="p">;</span>
    <span class="n">birthdays</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">day</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="结构体的指针">结构体的指针</h3>

<p>我们也可以用指针表示结构体。用指针的时候 <code class="language-plaintext highlighter-rouge">pointer-&gt;key</code> 相当于 <code class="language-plaintext highlighter-rouge">struct.key</code>。</p>

<p>运算符 <code class="language-plaintext highlighter-rouge">-&gt;</code> 的作用是获取「对象」的「成员」。</p>

<p>我们<strong>不该</strong>用 <code class="language-plaintext highlighter-rouge">*pointer.key</code>，因为它相当于 <code class="language-plaintext highlighter-rouge">*(pointer.key)</code>，将会尝试取出 <code class="language-plaintext highlighter-rouge">struct.key</code> 对应的内容。</p>

<p>如果硬要这么用，应该 <code class="language-plaintext highlighter-rouge">(*pointer).key</code>。因为 <code class="language-plaintext highlighter-rouge">(*pointer)</code> 就是 <code class="language-plaintext highlighter-rouge">struct</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Date</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">month</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">day</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">Date</span> <span class="n">b_day_yushi</span><span class="p">;</span>
    <span class="n">Date</span> <span class="o">*</span> <span class="n">pointer</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">b_day_yushi</span><span class="p">;</span>
    <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">year</span> <span class="o">=</span> <span class="mi">1992</span><span class="p">;</span>
    <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">month</span> <span class="o">=</span> <span class="s">"feb"</span><span class="p">;</span>
    <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">day</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
    <span class="c1">// 注意三种等效的用法</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">pointer</span><span class="p">).</span><span class="n">year</span> <span class="o">&lt;&lt;</span> <span class="s">"-"</span> 
              <span class="o">&lt;&lt;</span> <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">month</span>  <span class="o">&lt;&lt;</span> <span class="s">"-"</span>
              <span class="o">&lt;&lt;</span> <span class="n">b_day_yushi</span><span class="p">.</span><span class="n">day</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="结构体和类">结构体和类</h3>

<p>结构体 和 类 在 C++ 中非常接近。不同的是，结构体的成员 的 默认状态 是 public；而 类的成员 的 默认状态 是 private。</p>

<p>我们什么时候应该用 类，什么时候用 结构体 呢？如果我们的 成员/实例的取值 具有一定的「规则」，那么我们就应该用 类。反之则用 结构体。</p>

<p>一个例子是，如果我们要用一个 容器 封装「日期」，那么 表示日期的整数 有额外的 规则：它需要小于 31 并且大于零。由于这个 规则，我们需要写一个 类。这个规则 在 C++ 里很诡异地被称为 invariant。</p>

<h2 id="类">类</h2>

<h3 id="原则">原则</h3>

<ul>
  <li>类通过 构造函数 取得 资源。类似地，在 <code class="language-plaintext highlighter-rouge">python</code> 里所有的特性都 应该 在</li>
</ul>

<h3 id="不同的方法">不同的方法</h3>

<p>C++ 中类的方法有三种类型</p>

<ul>
  <li>private ：只有同一个 class 的方法，或该 class 的 friend class 可以访问。</li>
  <li>protected ：只有同一个 class 的方法，或该 class 的 friend class，或该 class 的子类可以访问。</li>
  <li>public ：任何可以看到这个 class 的地方都可以访问。</li>
</ul>

<p>方法的默认种类是 private</p>

<h3 id="一些运算符的读法">一些运算符的「读法」</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">*x</code> 读作: pointed by x （由x指向的）</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;x</code> 读作: address of x（x的地址）</li>
  <li><code class="language-plaintext highlighter-rouge">x.y</code> 读作: member y of object x （对象x的成员y）</li>
  <li><code class="language-plaintext highlighter-rouge">(*x).y</code> 读作: member y of object pointed by x（由x指向的对象的成员y）</li>
  <li><code class="language-plaintext highlighter-rouge">x-&gt;y</code> 读作: member y of object pointed by x (同上一个等价)</li>
  <li><code class="language-plaintext highlighter-rouge">x[0]</code> 读作: first object pointed by x（由x指向的第一个对象）</li>
  <li><code class="language-plaintext highlighter-rouge">x[1]</code> 读作: second object pointed by x（由x指向的第二个对象）</li>
  <li><code class="language-plaintext highlighter-rouge">x[n]</code> 读作: (n+1)th object pointed by x（由x指向的第n+1个对象）</li>
</ul>

<h3 id="构造函数">构造函数</h3>

<ul>
  <li>构造函数就是 python 里的 <code class="language-plaintext highlighter-rouge">__init__</code></li>
  <li>构造函数的格式是 <code class="language-plaintext highlighter-rouge">类名::类名</code></li>
  <li>构造函数的原型和实现中都没有返回值，也没有void 类型声明。构造函数必须这样写。一个构造函数永远没有返回值，也不用声明void</li>
  <li>构造函数可以被重载（为不同的参数写不同的函数）</li>
  <li>最好只在 构造函数 里用 <code class="language-plaintext highlighter-rouge">new</code> 创建指针</li>
</ul>

<p>使用构造函数的时候，现代的写法是</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Foo</span> <span class="n">f</span><span class="p">{</span><span class="n">arg_1</span><span class="p">,</span> <span class="n">arg_2</span><span class="p">};</span>
</code></pre></div></div>

<p>老式的写法是</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Foo</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg_1</span><span class="p">,</span> <span class="n">arg_2</span><span class="p">);</span>
</code></pre></div></div>

<p>新式写法更好的原因是，它清楚地表明了「类的实例被初始化/构造了」。而传统写法会与函数调用混淆。</p>

<p>应用新式写法，我们发现下面的语句是等价的</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">x</span> <span class="p">{</span><span class="mi">7</span><span class="p">};</span>
</code></pre></div></div>

<h3 id="默认构造函数">默认构造函数</h3>

<p>没有任何参数的构造函数是默认构造函数。对于类 <code class="language-plaintext highlighter-rouge">Y</code>，如果 <code class="language-plaintext highlighter-rouge">Y</code> 有默认构造函数，那么 <code class="language-plaintext highlighter-rouge">Y y</code> 会直接创建一个对象。</p>

<p>一般来说</p>

<h3 id="析构函数">析构函数</h3>

<ul>
  <li>析构函数相当于 python 里的 <code class="language-plaintext highlighter-rouge">__del__</code></li>
  <li>析构函数的格式是 <code class="language-plaintext highlighter-rouge">类名::~类名</code></li>
  <li>每一个「拥有资源」的类都应该有析构函数</li>
</ul>

<p>写下了析构函数之后，当我们离开某一个 scope 后，这个 scope 里的对象会自动被执行析构函数。例子</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
    <span class="kt">double</span><span class="o">*</span> <span class="n">elem</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">{</span><span class="n">s</span><span class="p">},</span> <span class="n">elem</span><span class="p">{</span><span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">s</span><span class="p">]}</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span><span class="k">delete</span><span class="p">[]</span> <span class="n">elem</span><span class="p">;}</span>  <span class="c1">// 析构函数</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="n">Foo</span> <span class="n">f</span> <span class="p">{</span><span class="n">n</span><span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="cm">/*
    * 如果 Foo 没有实现析构函数，会消耗大量内存
    */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">func</span><span class="p">(</span><span class="mi">10000000</span><span class="p">);</span>
    <span class="p">}</span> <span class="c1">// 离开之后 func 内 Foo 实例占用的内存被自动释放</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="生成析构函数">生成析构函数</h3>

<p>如果某个类的「成员」有析构函数，那么这个类离开 scope 之后，这些「成员的析构函数」会被自动调用。这个行为被称为「编译器为这个类 生成 了一个析构函数」，所以这个不存在的析构函数被称为「生成析构函数」generated destructors。</p>

<p>例子，注意这段代码比上面的代码慢很多</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="n">Foo</span> <span class="n">f</span> <span class="p">{</span><span class="n">n</span><span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="cm">/*
    * Foo 没有实现析构函数，但没有内存泄漏
    */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">func</span><span class="p">(</span><span class="mi">10000000</span><span class="p">);</span>
    <span class="p">}</span> <span class="c1">// 离开之后 func 内 Foo.data 占用的内存被自动释放</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="指针-1">指针</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">类名 * 指针名</code> 会定义一个类的指针。</li>
  <li>如果我们想通过指针访问成员，我们需要 <code class="language-plaintext highlighter-rouge">指针名-&gt;成员</code></li>
</ul>

<h3 id="运算符重载">运算符重载</h3>

<p>我们可以自己定义运算符，它的格式是：</p>

<p><code class="language-plaintext highlighter-rouge">类名 operator 符号 (参数类型 参数名)</code></p>

<p>这个格式类似于函数的定义，只不过没有 <code class="language-plaintext highlighter-rouge">operator</code></p>

<p><code class="language-plaintext highlighter-rouge">返回数据类型 函数名 (参数类型 参数名)</code></p>

<h3 id="this">this</h3>

<p><code class="language-plaintext highlighter-rouge">this</code> 仅仅被用在「类的内部」（什么意思？），它表示指向「这个类的某个实例/对象」的指针。</p>

<p>它可以被用来检查参数是否是对象自己</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">FOO</span><span class="o">::</span><span class="n">is_self</span> <span class="p">(</span><span class="n">FOO</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">object</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="静态成员-static-member">静态成员 static member</h3>

<p>静态成员的内容不依赖于具体的对象/实例，它感觉像是「属于某个类的全局变量」</p>

<p>静态成员的格式是 <code class="language-plaintext highlighter-rouge">static 类型 变量名</code></p>

<p>为了避免静态成员被重复定义，静态成员的定义<strong>必须</strong>在类的定义之外。</p>

<p>例子：记录总共创建了多少实例</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">Foo</span><span class="p">()</span> <span class="p">{</span><span class="n">n</span><span class="o">++</span><span class="p">;};</span>
        <span class="o">~</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span><span class="n">n</span><span class="o">--</span><span class="p">;};</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">Foo</span><span class="o">::</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">Foo</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"there are "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">" instances of Foo"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="friend">Friend</h3>

<p>我们在定义类的时候，可以通过加上 <code class="language-plaintext highlighter-rouge">friend</code> 关键字来将「函数」或者「类」定义为 Friend。</p>

<p>Friend 可以访问该类的 <code class="language-plaintext highlighter-rouge">private</code> 或 <code class="language-plaintext highlighter-rouge">protected</code> 的内容。</p>

<p>例子 - friend 函数：<code class="language-plaintext highlighter-rouge">a_plus_one</code> 函数可以读写 <code class="language-plaintext highlighter-rouge">Foo</code> 的私有变量 <code class="language-plaintext highlighter-rouge">a</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="nl">private:</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">a_plus_one</span><span class="p">(</span><span class="n">Foo</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
    <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">show</span><span class="p">(){</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a is "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">a_plus_one</span><span class="p">(</span><span class="n">Foo</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">){</span>
    <span class="n">f</span><span class="p">.</span><span class="n">a</span> <span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
    <span class="n">a_plus_one</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>例子 - friend 类：<code class="language-plaintext highlighter-rouge">Bar</code> 的 <code class="language-plaintext highlighter-rouge">eat</code> 函数可以获取 <code class="language-plaintext highlighter-rouge">Foo</code> 的私有变量 <code class="language-plaintext highlighter-rouge">a</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="nl">private:</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">friend</span> <span class="k">class</span> <span class="nc">Bar</span><span class="p">;</span>
    <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">inc</span><span class="p">(){</span><span class="n">a</span><span class="o">++</span><span class="p">;}</span>
        <span class="kt">void</span> <span class="nf">show</span><span class="p">(){</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a is "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">{</span>
    <span class="nl">private:</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">eat</span><span class="p">(</span><span class="n">Foo</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">){</span><span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">a</span><span class="p">;}</span>
        <span class="kt">void</span> <span class="nf">show</span><span class="p">(){</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"b is "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">Bar</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
    <span class="n">f</span><span class="p">.</span><span class="n">inc</span><span class="p">();</span>
    <span class="n">b</span><span class="p">.</span><span class="n">eat</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="继承">继承</h3>

<p>C++ 中有子类的概念，子类继承父类的格式是 <code class="language-plaintext highlighter-rouge">class 字类名: 类型 父类名</code></p>

<p>C++ 中也可以多重继承，其格式是 <code class="language-plaintext highlighter-rouge">class 字类名: 类型 父类名#1 类型 父类名#2 ...</code></p>

<p>子类不会继承父类的构造函数和析构函数</p>

<p>其中，<code class="language-plaintext highlighter-rouge">类型</code> 包括 <code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">protected</code> 和 <code class="language-plaintext highlighter-rouge">public</code>。</p>

<p><code class="language-plaintext highlighter-rouge">protected</code> 下的方法 / 特性不能直接被成员调用，必须通过「这个类的子类的成员」来使用。</p>

<p>这里的 <code class="language-plaintext highlighter-rouge">类型</code> 的作用是保护从父类继承的成员（方法 &amp; 特性）。如果 <code class="language-plaintext highlighter-rouge">类型</code> 是 <code class="language-plaintext highlighter-rouge">private</code>，那么子类从父类继承的成员就是 <code class="language-plaintext highlighter-rouge">private</code></p>

<p><a href="https://stackoverflow.com/a/1372858">例子</a></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> 
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="nl">protected:</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="c1">// x is public</span>
    <span class="c1">// y is protected</span>
    <span class="c1">// z is not accessible from B</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">protected</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="c1">// x is protected</span>
    <span class="c1">// y is protected</span>
    <span class="c1">// z is not accessible from C</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">private</span> <span class="n">A</span>    <span class="c1">// 'private' is default for classes</span>
<span class="p">{</span>
    <span class="c1">// x is private</span>
    <span class="c1">// y is private</span>
    <span class="c1">// z is not accessible from D</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="虚函数">虚函数</h3>

<blockquote>
  <p>经验规则：如果一个 类 有虚函数，那么这个类需要一个 虚 析构函数</p>
</blockquote>

<p>我们可以在 基类 和 继承类 里定义「同名、同类型」的函数。这样的函数叫虚函数。实例使用的函数 来自的地方，是 基类 还是 继承类，在运行时决定。所以这个特性也叫 runtime polymorphism, dynamic dispatch, runtime dispatch。</p>

<p>使用虚函数的场景如下。有的时候我们创造了 抽象的基类，和许多不同的 派生类。这个时候我们想要写一个 函数 来 抽象地处理 所有的 派生类。这个时候我们的 函数 及其 调用 大概是这样</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="err">基类</span> <span class="o">&amp;</span> <span class="err">实例</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">实例</span><span class="p">.</span><span class="err">方法</span><span class="p">();</span>  <span class="c1">// 对于这个函数而言，它认为这个实例来自基类</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">func</span><span class="p">(</span><span class="err">派生类实例</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>此时，在函数 <code class="language-plaintext highlighter-rouge">func</code> 内部，函数认为它接受的 参数 是一个「基类的实例」。如果在 基类 里我们使用了 虚函数，那么 C++ 编译器就会自动在 <code class="language-plaintext highlighter-rouge">func</code> 内部的 <code class="language-plaintext highlighter-rouge">实例.方法()</code> 处调用 派生类 的方法。</p>

<p>下面是一个稍微具体一点的例子</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"B"</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">count</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">D1</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"D1"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">1</span><span class="p">;}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">call</span><span class="p">(</span><span class="n">Base</span> <span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span>
    <span class="cm">/*
    * 因为 D1 派生于 Base 所以 call 也可以接受 D1 类实例
    * 如果 count 不是虚函数，那么 call 里 obj.count() 会返回 0
    */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"As Base, name: "</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">"; count : "</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">D1</span> <span class="n">d1</span><span class="p">;</span>
    <span class="n">call</span><span class="p">(</span><span class="n">d1</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"As D1, name: "</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">"; count: "</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="const-function">const function</h3>

<p><a href="https://stackoverflow.com/questions/3141087/what-is-meant-with-const-at-end-of-function-declaration">来源</a></p>

<p>有的时候我们能看到这样的代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> 
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">Bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">random_arg</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="c1">// code</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>这里面的 <code class="language-plaintext highlighter-rouge">const</code> 让我十分困惑：它为什么在这里？它的作用是什么？</p>

<p>当我们「使用」一个类的成员函数的时候，我们写出下面这样的代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>
<span class="n">f</span><span class="p">.</span><span class="n">Bar</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</code></pre></div></div>

<p>这等价于</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>
<span class="n">Foo_Bar</span><span class="p">(</span><span class="k">const</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<p>所以，<code class="language-plaintext highlighter-rouge">int Bar(int random_arg) const</code> 里的 <code class="language-plaintext highlighter-rouge">const</code> 保证了成员，或者说 <code class="language-plaintext highlighter-rouge">this</code> 是一个常量。这导致了 <code class="language-plaintext highlighter-rouge">Bar</code> 这个函数无法更改<strong>任何</strong>成员函数。</p>

<p>这样的函数叫 <code class="language-plaintext highlighter-rouge">const function</code></p>

<p>有的时候我们希望，一个成员变量永远能被改变，即使是 <code class="language-plaintext highlighter-rouge">const function</code>。这个时候我们用关键字 <code class="language-plaintext highlighter-rouge">mutable</code> 来修饰这个变量。</p>

<h2 id="其他话题">其他话题</h2>

<h3 id="头文件里放什么">头文件里放什么</h3>

<p>一个 C++ 的项目里 通常有很多 头文件 (<code class="language-plaintext highlighter-rouge">.h</code>, <code class="language-plaintext highlighter-rouge">.hpp</code> 甚至 <code class="language-plaintext highlighter-rouge">.tpp</code>) 和 代码文件 (<code class="language-plaintext highlighter-rouge">.cpp</code>)。什么东西应该被放进 头文件 (head file) 而什么应该被放进 代码文件 (code file) 呢？</p>

<p>我在 Stackoverflow 上看到了一个 <a href="https://stackoverflow.com/a/1945866">很优雅的答案</a>。简而言之，</p>

<ul>
  <li>在头文件里，我们放入「很多文件 共同需要的 信息」，即 <strong>抽象定义</strong>。</li>
  <li>在代码文件里，我们放入「只被这个文件需要的 信息」，即 <strong>具体实现</strong>。</li>
</ul>

<h3 id="map-的迭代">map 的迭代</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">std:map</code> 里，每个「元素的类型」是 <code class="language-plaintext highlighter-rouge">pair</code>，<code class="language-plaintext highlighter-rouge">pair.first</code> = 键；<code class="language-plaintext highlighter-rouge">pair.second</code> = 值。</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">std::map</code> 可以用</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">item</span> <span class="o">:</span> <span class="n">map_instance</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">;}</span>
</code></pre></div></div>
<p>的格式迭代。其中，<code class="language-plaintext highlighter-rouge">item</code> 的类型是 <a href="https://en.cppreference.com/w/cpp/utility/pair"><code class="language-plaintext highlighter-rouge">pair</code></a>。我们可以用 <code class="language-plaintext highlighter-rouge">item.first</code> 获取 键；用 <code class="language-plaintext highlighter-rouge">item.second</code> 获取 值。一个完整的例子如下</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"apple"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"orange"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">item</span> <span class="o">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="vim-配置">Vim 配置</h3>

<p>我编写 C++ 代码的时候，习惯使用 vim 作为编辑器，搭配插件 <a href="https://github.com/dense-analysis/ale">ale</a> 和 <a href="https://github.com/ycm-core/YouCompleteMe">YouCompleteMe</a>。前者是作用是 检查代码语法，后者的作用是 代码的自动补全。在插件 <a href="https://github.com/dense-analysis/ale">ale</a> 进行 语法检查 的时候，我们需要「告诉」vim 我们的编译选项。由于 不同项目使用的 编译选项 不同，所以我倾向于 在不同项目下 使用不同的 vim 配置。具体的做法如下。</p>

<p>首先，向系统的 VIM 配置文件 (<code class="language-plaintext highlighter-rouge">vimrc</code>) 添加下面两行代码。大部分 Linux 系统下，这个文件处于 <code class="language-plaintext highlighter-rouge">$HOME/.vimrc</code> 或者 <code class="language-plaintext highlighter-rouge">$HOME/.vim/vimrc</code>。</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="nb">exrc</span>
<span class="k">set</span> <span class="nb">secure</span>
</code></pre></div></div>

<p>上面的 两行代码 能够让 vim 读取「当前的工作文件夹」下的 配置文件。其次，在 C++ 项目的文件夹（即，我们的工作文件夹）里，创建一个 命名为 <code class="language-plaintext highlighter-rouge">.vimrc</code> 的文件，加入下面的代码。</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">g:ale_linters</span> <span class="p">=</span> <span class="p">{</span><span class="s1">'cpp'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'clang'</span><span class="p">]}</span>  " use clang <span class="k">compiler</span>
<span class="k">let</span> cpp_flags <span class="p">=</span> <span class="s1">'-std=c++11 -Wall '</span>  " <span class="k">c</span><span class="p">++</span> standard &amp; show <span class="k">all</span> warnings
<span class="k">let</span> <span class="nv">g:ale_cpp_clang_options</span> <span class="p">=</span> cpp_flags  " <span class="k">set</span> the flag <span class="k">for</span> linting
</code></pre></div></div>

<p>我们可以在 <code class="language-plaintext highlighter-rouge">cpp_flags</code> 里加入更多的参数，来满足项目的需要。下面的 <code class="language-plaintext highlighter-rouge">.vimrc</code> 文件是我在使用 <code class="language-plaintext highlighter-rouge">Eigen</code> 库时使用的参数。</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">g:ale_linters</span> <span class="p">=</span> <span class="p">{</span><span class="s1">'cpp'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'clang'</span><span class="p">]}</span>  " use clang <span class="k">compiler</span>
<span class="k">let</span> cpp_flags <span class="p">=</span> <span class="s1">'-std=c++11 -Wall '</span>  " <span class="k">c</span><span class="p">++</span> standard &amp; show <span class="k">all</span> warnings
<span class="k">let</span> cpp_flags <span class="p">=</span> cpp_flags <span class="p">.</span> <span class="s1">'-I/usr/local/include/eigen3'</span> <span class="p">.</span> <span class="s1">' '</span>  " <span class="k">for</span> eigen
<span class="k">let</span> cpp_flags <span class="p">=</span> cpp_flags <span class="p">.</span> <span class="s1">'-Wno-unknown-warning-option'</span> <span class="p">.</span> <span class="s1">' '</span>  " supress eigen warnings
<span class="k">let</span> <span class="nv">g:ale_cpp_clang_options</span> <span class="p">=</span> cpp_flags  " <span class="k">set</span> the flag <span class="k">for</span> linting
</code></pre></div></div>


</div>


    </div>

  </body>

</html>
