<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>C++ 笔记</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link rel="stylesheet" href="/assets/css/styles/github-gist.css">
    <script src="/assets/js/toc.js"></script>
    <script src="/assets/js/highlight.pack.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true
        }
      });
    </script>

    <script type="text/javascript" id="MathJax-script" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"
      >
    </script>
    
    </head>

  <body>
    <script>hljs.initHighlightingOnLoad();</script>
    
    <nav>
    <ul>
        
        <li>
        <a href=/
            
        >
            Notes
        </a>
        </li>
        
        <li>
        <a href=/about.html
            
        >
            About
        </a>
        </li>
        
    </ul>
</nav>


    <div class="main">
        <div id="side_bar">
    17 Apr 2020
</div>

<div class="post center">
    <ul id="markdown-toc">
  <li><a href="#函数" id="markdown-toc-函数">函数</a>    <ul>
      <li><a href="#inline" id="markdown-toc-inline">inline</a></li>
      <li><a href="#在不同源代码中共享函数" id="markdown-toc-在不同源代码中共享函数">在不同源代码中共享函数</a></li>
      <li><a href="#传递指针给函数" id="markdown-toc-传递指针给函数">传递指针给函数</a></li>
      <li><a href="#没有变量名的参数" id="markdown-toc-没有变量名的参数">没有变量名的参数</a></li>
    </ul>
  </li>
  <li><a href="#指针" id="markdown-toc-指针">指针</a>    <ul>
      <li><a href="#基础" id="markdown-toc-基础">基础</a></li>
      <li><a href="#声明指针" id="markdown-toc-声明指针">声明指针</a></li>
      <li><a href="#内存" id="markdown-toc-内存">内存</a></li>
      <li><a href="#指针不知道内存的长度" id="markdown-toc-指针不知道内存的长度">指针不知道内存的长度</a></li>
      <li><a href="#给自定义类型分配内存" id="markdown-toc-给自定义类型分配内存">给自定义类型分配内存</a></li>
      <li><a href="#释放内存" id="markdown-toc-释放内存">释放内存</a></li>
      <li><a href="#null-指针" id="markdown-toc-null-指针">null 指针</a></li>
    </ul>
  </li>
  <li><a href="#结构体" id="markdown-toc-结构体">结构体</a>    <ul>
      <li><a href="#简介" id="markdown-toc-简介">简介</a></li>
      <li><a href="#结构体的指针" id="markdown-toc-结构体的指针">结构体的指针</a></li>
      <li><a href="#结构体和类" id="markdown-toc-结构体和类">结构体和类</a></li>
    </ul>
  </li>
  <li><a href="#类" id="markdown-toc-类">类</a>    <ul>
      <li><a href="#原则" id="markdown-toc-原则">原则</a></li>
      <li><a href="#不同的方法" id="markdown-toc-不同的方法">不同的方法</a></li>
      <li><a href="#一些运算符的读法" id="markdown-toc-一些运算符的读法">一些运算符的「读法」</a></li>
      <li><a href="#构造函数" id="markdown-toc-构造函数">构造函数</a></li>
      <li><a href="#默认构造函数" id="markdown-toc-默认构造函数">默认构造函数</a></li>
      <li><a href="#析构函数" id="markdown-toc-析构函数">析构函数</a></li>
      <li><a href="#生成析构函数" id="markdown-toc-生成析构函数">生成析构函数</a></li>
      <li><a href="#指针-1" id="markdown-toc-指针-1">指针</a></li>
      <li><a href="#运算符重载" id="markdown-toc-运算符重载">运算符重载</a></li>
      <li><a href="#this" id="markdown-toc-this">this</a></li>
      <li><a href="#静态成员-static-member" id="markdown-toc-静态成员-static-member">静态成员 static member</a></li>
      <li><a href="#friend" id="markdown-toc-friend">Friend</a></li>
      <li><a href="#继承" id="markdown-toc-继承">继承</a></li>
      <li><a href="#虚函数" id="markdown-toc-虚函数">虚函数</a></li>
      <li><a href="#const-function" id="markdown-toc-const-function">const function</a></li>
    </ul>
  </li>
  <li><a href="#其他话题" id="markdown-toc-其他话题">其他话题</a>    <ul>
      <li><a href="#头文件里放什么" id="markdown-toc-头文件里放什么">头文件里放什么</a></li>
      <li><a href="#map-的迭代" id="markdown-toc-map-的迭代">map 的迭代</a></li>
      <li><a href="#vector-作为-map-的键" id="markdown-toc-vector-作为-map-的键">vector 作为 map 的键</a></li>
      <li><a href="#vim-配置" id="markdown-toc-vim-配置">Vim 配置</a></li>
    </ul>
  </li>
</ul>

<hr />

<p>这是我在学习 C++ 的时候记下来的笔记；我主要参考的书籍是<a href="https://www.amazon.co.uk/Programming-Principles-Practice-Using-C/dp/0321992784">这一本</a>。</p>

<p>我写 C++ 主要目的是 加速 Python。</p>

<hr />

<h2 id="函数">函数</h2>

<h3 id="inline">inline</h3>

<p>在定义函数的时候，我们可以尝试在 函数前面 加上 <code class="language-plaintext highlighter-rouge">inline</code>。它的作用是把 函数 变成 类似于宏的东西。这样，编译的时候，编译器会直接把 函数部分的代码 复制到 调用函数的地方。</p>

<p><code class="language-plaintext highlighter-rouge">inline</code> 只是一个给编译器的「建议」。对于太长的函数，编译器有可能忽略掉这个建议。</p>

<p>简而言之，对于特别短的函数，<code class="language-plaintext highlighter-rouge">inline</code> 有可能让它更快。</p>

<p><code class="language-plaintext highlighter-rouge">inline</code> 还可以用于「躲避」掉对函数的重复定义。比如说，如果我们在头文件 <code class="language-plaintext highlighter-rouge">*.h</code> 里定义函数，那么 <code class="language-plaintext highlighter-rouge">inline</code> 可以让这个「函数」作为宏被替换进源代码里；这样函数就不会重复定义了。</p>

<h3 id="在不同源代码中共享函数">在不同源代码中共享函数</h3>

<p><a href="https://stackoverflow.com/a/25274411">参考链接</a></p>

<p>如果我们想要在我们的「项目」下的「不同源代码」里共用一个函数，我们可以通过下面的三个步骤完成</p>

<p>1 - 将函数的定义写进「头文件」</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef FUNCTIONS_H_INCLUDED
#define FUNCTIONS_H_INCLUDED
</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// Function prototype, its declaration</span>

<span class="cp">#endif
</span></code></pre></div></div>

<p>（其中的 <code class="language-plaintext highlighter-rouge">#ifndef</code> 之类的东西叫做 <a href="https://en.wikipedia.org/wiki/Include_guard">include gard</a>，用来避免 重复引用头文件 造成的 对同一个函数的 多次定义。注意，include gard 只在「同一个」.cpp 源文件内起作用。）</p>

<p>2 - 在「第一个」源文件里定义函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "functions.h"
</span>
<span class="c1">// Function definition</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>3 - 在「其他源文件」中 <code class="language-plaintext highlighter-rouge">include</code> 头文件，使用函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include "functions.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"add(1, 2) = "</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="传递指针给函数">传递指针给函数</h3>

<p>C 里传递指针式传递「指针」，<code class="language-plaintext highlighter-rouge">* arg</code></p>

<pre><code class="language-C">#include "stdio.h"

void triple(int *num) {
    *num = *num * 3;
}

int main(){
    int a = 2;
    triple(&amp;a);
    printf("2 x 3 = %d", a); // a = 6
}
</code></pre>

<p>C++ 里可以做同样的事情，不过也可以传递「地址」</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="kt">void</span> <span class="nf">triple</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">triple</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2 x 3 = "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// a = 6</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="没有变量名的参数">没有变量名的参数</h3>

<p>在某些特殊的情况下，我们会写出下面的函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">one</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>这个函数 的输入 是一个小数，输出 永远为 1.0。此时，输入的参数 并不会进入 实际的计算，所以我么不需要给它 变量名。这就是有点怪异的 <code class="language-plaintext highlighter-rouge">one(double)</code> 部分的由来。</p>

<h2 id="指针">指针</h2>

<h3 id="基础">基础</h3>

<ul>
  <li>声明指向类型的指针 <code class="language-plaintext highlighter-rouge">类型 * 指针名</code></li>
  <li>获取指针的内容 (dereference) <code class="language-plaintext highlighter-rouge">* 指针名</code></li>
  <li>我们也可以用 <code class="language-plaintext highlighter-rouge">指针名[位移]</code> 来取得地址的内容，<code class="language-plaintext highlighter-rouge">[]</code> 叫 subscript operator。</li>
  <li><code class="language-plaintext highlighter-rouge">指针名[0]</code> 等价于 <code class="language-plaintext highlighter-rouge">* 指针名</code></li>
  <li>获取一个对象的地址 <code class="language-plaintext highlighter-rouge">&amp; 对象名</code>，<code class="language-plaintext highlighter-rouge">&amp;</code> 叫 address of operator</li>
</ul>

<p>使用 <code class="language-plaintext highlighter-rouge">sizeof</code> 函数可以获取 不同对象/指针 占用的内存，下面是一些结果</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">uint8_t:</span>  <span class="mi">1</span>  <span class="c1">// 数据占用的内存</span>
<span class="kt">double</span><span class="o">:</span>   <span class="mi">8</span>  <span class="c1">// 数据占用的内存</span>
<span class="o">*</span><span class="kt">uint8_t</span><span class="o">:</span> <span class="mi">8</span>  <span class="c1">// 指针占用的内存</span>
<span class="o">*</span><span class="kt">double</span><span class="o">:</span>  <span class="mi">8</span>  <span class="c1">// 指针占用的内存</span>
</code></pre></div></div>

<h3 id="声明指针">声明指针</h3>

<p>我们可以先「给一个变量赋值」，再「得到指向这个变量的指针」</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果我们想要「先创建一个指针」，接着「给指针指向的内存赋值」，直觉上我们会写出这样的代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这段代码一定不会编译成功</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pa</span><span class="p">;</span>  <span class="c1">// 没有初始化，得到一个随机地址；这样的代码永远不应该出现</span>
    <span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的代码首先生成了一个「随机的地址」，之后向这个地址写入了 <code class="language-plaintext highlighter-rouge">1</code>。这样是不对的，因为我们有可能改变程序里其他对象的值。</p>

<p>不过，如果我们主动声明「指针指向的变量」，即确定「指针的地址」，那么我们就可以给这个地址赋值了。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 可以编译成功</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pa</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>还有一种方法是使用 <code class="language-plaintext highlighter-rouge">new</code> 主动分配内存</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// 得到一个 heap 里的随机地址</span>
    <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="内存">内存</h3>

<p>为了更好的理解指针，我们需要理解 C++ 如何使用 电脑中的内存。</p>

<table>
  <thead>
    <tr>
      <th>一段 C++ 代码占用的内存</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Code 代码本身占用的内存</td>
    </tr>
    <tr>
      <td>Static Data 声明的全局变量</td>
    </tr>
    <tr>
      <td>Stack 函数使用的内存（函数的参数、临时变量）</td>
    </tr>
    <tr>
      <td>Free store 其他的内存，也叫 heap</td>
    </tr>
  </tbody>
</table>

<p>如果我们要使用 heap，我们使用关键字 <code class="language-plaintext highlighter-rouge">new</code>，比如</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</code></pre></div></div>

<p>此外，我们可以用「变量」来指定「指针指向的内存」的长度</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">double</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</code></pre></div></div>

<p>此外，我们也可以直接通过 <code class="language-plaintext highlighter-rouge">{}</code> 给指针指向的内存赋值</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</code></pre></div></div>

<h3 id="指针不知道内存的长度">指针不知道内存的长度</h3>

<p><code class="language-plaintext highlighter-rouge">double * p = new double[2]</code> 在 free store (heap) 区域里分配了 2 个 <code class="language-plaintext highlighter-rouge">double</code> 占用的内存，并且返回一个指向这一小块内存的指针 <code class="language-plaintext highlighter-rouge">p</code>。但是，指针<strong>不知道</strong>自己指向的内存的长度。</p>

<p>这意味着，我们可以使用所有 free store / heap 里的内存。这样是不对的，会导致神秘的错误，制造最难查的 bug。这种错误的行为叫 out-of-range access。</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="p">...</span>
</code></pre></div></div>

<p>避免 out-of-range access 的方法是使用 <code class="language-plaintext highlighter-rouge">vector</code></p>

<h3 id="给自定义类型分配内存">给自定义类型分配内存</h3>

<p>假设我们的自定义类型为 <code class="language-plaintext highlighter-rouge">X</code> 并且<strong>有</strong>默认的构造函数，那么我们可以这样</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">X</span><span class="o">*</span> <span class="n">px1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">X</span><span class="p">;</span>  <span class="c1">// 使用默认构造函数创建一个 X 实例</span>
<span class="n">X</span><span class="o">*</span> <span class="n">px1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">X</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">// 使用默认构造函数创建 10 个 X 实例</span>
</code></pre></div></div>

<p>如果我们的自定义类型为 <code class="language-plaintext highlighter-rouge">Y</code> 并且<strong>没有</strong>默认的构造函数，那么我们可以这样</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Y</span><span class="o">*</span> <span class="n">py1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Y</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>  <span class="c1">// 使用参数 1 初始化 1 个 Y 实例</span>
<span class="n">Y</span><span class="o">*</span> <span class="n">py2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Y</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>  <span class="c1">// 使用参数 1-5 初始化 5 个 Y 实例</span>
</code></pre></div></div>

<h3 id="释放内存">释放内存</h3>

<p>我们需要「手动释放」不需要的指针，来解放这个 指针 对应的 内存。语法如下</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">delete</span> <span class="n">p</span>  <span class="c1">// 释放单个对象占用的内存</span>
<span class="k">delete</span><span class="p">[]</span> <span class="n">p</span>  <span class="c1">// 释放「多个对象组成的数组」所占用的内存</span>
</code></pre></div></div>

<p>我们需要「自行抉择」什么时候、如何释放内存。我们可以使用 garbage collector 来自动帮我们做这件事。如果我们不释放内存，我们的程序会在逐渐运行的时候，消耗掉 所有内存 然后被 操作系统 残忍地杀掉。</p>

<h3 id="null-指针">null 指针</h3>

<p>如果我们在 创建指针的时候 暂时没有一个「用于初始化」的地址，那么我们<strong>应该</strong>用 <code class="language-plaintext highlighter-rouge">nullptr</code> 来 初始化这个指针</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="o">*</span> <span class="n">p0</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
</code></pre></div></div>

<p>这会将 <code class="language-plaintext highlighter-rouge">p0</code> 的地址设定为 <code class="language-plaintext highlighter-rouge">0x0</code>。</p>

<p>此外，不同的编译器 对于 没有初始化的指针 有不同的处理。苹果的 <code class="language-plaintext highlighter-rouge">clang11</code> 会将 没有初始化的指针 自动设置为 <code class="language-plaintext highlighter-rouge">nummptr</code> 但是 <code class="language-plaintext highlighter-rouge">g++9.2</code> 不会。</p>

<p>我们可以用 下面两种方法 判断 指针 是否属于 <code class="language-plaintext highlighter-rouge">nullptr</code>；我们会这么做的原因是，有的时候我们需要 构建一个指针——它在 某种情况下 有效，指向某个地址；在 另外的情况下 无效，指向 <code class="language-plaintext highlighter-rouge">nullptr</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>  <span class="c1">// 第一种</span>
<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// 第二种，推荐</span>
</code></pre></div></div>

<h2 id="结构体">结构体</h2>

<h3 id="简介">简介</h3>

<p>C++ 里最简单的 结构体 用法</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
</span>
<span class="k">struct</span> <span class="nc">Date</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">month</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">day</span><span class="p">;</span>
<span class="p">}</span> <span class="n">birthdays</span> <span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">birthdays</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">year</span> <span class="o">=</span> <span class="mi">1992</span><span class="p">;</span>
    <span class="n">birthdays</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">month</span> <span class="o">=</span> <span class="s">"feb"</span><span class="p">;</span>
    <span class="n">birthdays</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">day</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
    <span class="n">birthdays</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">year</span> <span class="o">=</span> <span class="mi">1989</span><span class="p">;</span>
    <span class="n">birthdays</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">month</span> <span class="o">=</span> <span class="s">"may"</span><span class="p">;</span>
    <span class="n">birthdays</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">day</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="结构体的指针">结构体的指针</h3>

<p>我们也可以用指针表示结构体。用指针的时候 <code class="language-plaintext highlighter-rouge">pointer-&gt;key</code> 相当于 <code class="language-plaintext highlighter-rouge">struct.key</code>。</p>

<p>运算符 <code class="language-plaintext highlighter-rouge">-&gt;</code> 的作用是获取「对象」的「成员」。</p>

<p>我们<strong>不该</strong>用 <code class="language-plaintext highlighter-rouge">*pointer.key</code>，因为它相当于 <code class="language-plaintext highlighter-rouge">*(pointer.key)</code>，将会尝试取出 <code class="language-plaintext highlighter-rouge">struct.key</code> 对应的内容。</p>

<p>如果硬要这么用，应该 <code class="language-plaintext highlighter-rouge">(*pointer).key</code>。因为 <code class="language-plaintext highlighter-rouge">(*pointer)</code> 就是 <code class="language-plaintext highlighter-rouge">struct</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
</span>
<span class="k">struct</span> <span class="nc">Date</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">month</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">day</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">Date</span> <span class="n">b_day_yushi</span><span class="p">;</span>
    <span class="n">Date</span> <span class="o">*</span> <span class="n">pointer</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">b_day_yushi</span><span class="p">;</span>
    <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">year</span> <span class="o">=</span> <span class="mi">1992</span><span class="p">;</span>
    <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">month</span> <span class="o">=</span> <span class="s">"feb"</span><span class="p">;</span>
    <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">day</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
    <span class="c1">// 注意三种等效的用法</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">pointer</span><span class="p">).</span><span class="n">year</span> <span class="o">&lt;&lt;</span> <span class="s">"-"</span> 
              <span class="o">&lt;&lt;</span> <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">month</span>  <span class="o">&lt;&lt;</span> <span class="s">"-"</span>
              <span class="o">&lt;&lt;</span> <span class="n">b_day_yushi</span><span class="p">.</span><span class="n">day</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="结构体和类">结构体和类</h3>

<p>结构体 和 类 在 C++ 中非常接近。不同的是，结构体的成员 的 默认状态 是 public；而 类的成员 的 默认状态 是 private。</p>

<p>我们什么时候应该用 类，什么时候用 结构体 呢？如果我们的 成员/实例的取值 具有一定的「规则」，那么我们就应该用 类。反之则用 结构体。</p>

<p>一个例子是，如果我们要用一个 容器 封装「日期」，那么 表示日期的整数 有额外的 规则：它需要小于 31 并且大于零。由于这个 规则，我们需要写一个 类。这个规则 在 C++ 里很诡异地被称为 invariant。</p>

<h2 id="类">类</h2>

<h3 id="原则">原则</h3>

<ul>
  <li>类通过 构造函数 取得 资源。类似地，在 <code class="language-plaintext highlighter-rouge">python</code> 里所有的特性都 应该 在</li>
</ul>

<h3 id="不同的方法">不同的方法</h3>

<p>C++ 中类的方法有三种类型</p>

<ul>
  <li>private ：只有同一个 class 的方法，或该 class 的 friend class 可以访问。</li>
  <li>protected ：只有同一个 class 的方法，或该 class 的 friend class，或该 class 的子类可以访问。</li>
  <li>public ：任何可以看到这个 class 的地方都可以访问。</li>
</ul>

<p>方法的默认种类是 private</p>

<h3 id="一些运算符的读法">一些运算符的「读法」</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">*x</code> 读作: pointed by x （由x指向的）</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;x</code> 读作: address of x（x的地址）</li>
  <li><code class="language-plaintext highlighter-rouge">x.y</code> 读作: member y of object x （对象x的成员y）</li>
  <li><code class="language-plaintext highlighter-rouge">(*x).y</code> 读作: member y of object pointed by x（由x指向的对象的成员y）</li>
  <li><code class="language-plaintext highlighter-rouge">x-&gt;y</code> 读作: member y of object pointed by x (同上一个等价)</li>
  <li><code class="language-plaintext highlighter-rouge">x[0]</code> 读作: first object pointed by x（由x指向的第一个对象）</li>
  <li><code class="language-plaintext highlighter-rouge">x[1]</code> 读作: second object pointed by x（由x指向的第二个对象）</li>
  <li><code class="language-plaintext highlighter-rouge">x[n]</code> 读作: (n+1)th object pointed by x（由x指向的第n+1个对象）</li>
</ul>

<h3 id="构造函数">构造函数</h3>

<ul>
  <li>构造函数就是 python 里的 <code class="language-plaintext highlighter-rouge">__init__</code></li>
  <li>构造函数的格式是 <code class="language-plaintext highlighter-rouge">类名::类名</code></li>
  <li>构造函数的原型和实现中都没有返回值，也没有void 类型声明。构造函数必须这样写。一个构造函数永远没有返回值，也不用声明void</li>
  <li>构造函数可以被重载（为不同的参数写不同的函数）</li>
  <li>最好只在 构造函数 里用 <code class="language-plaintext highlighter-rouge">new</code> 创建指针</li>
</ul>

<p>使用构造函数的时候，现代的写法是</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Foo</span> <span class="n">f</span><span class="p">{</span><span class="n">arg_1</span><span class="p">,</span> <span class="n">arg_2</span><span class="p">};</span>
</code></pre></div></div>

<p>老式的写法是</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Foo</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg_1</span><span class="p">,</span> <span class="n">arg_2</span><span class="p">);</span>
</code></pre></div></div>

<p>新式写法更好的原因是，它清楚地表明了「类的实例被初始化/构造了」。而传统写法会与函数调用混淆。</p>

<p>应用新式写法，我们发现下面的语句是等价的</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">x</span> <span class="p">{</span><span class="mi">7</span><span class="p">};</span>
</code></pre></div></div>

<h3 id="默认构造函数">默认构造函数</h3>

<p>没有任何参数的构造函数是默认构造函数。对于类 <code class="language-plaintext highlighter-rouge">Y</code>，如果 <code class="language-plaintext highlighter-rouge">Y</code> 有默认构造函数，那么 <code class="language-plaintext highlighter-rouge">Y y</code> 会直接创建一个对象。</p>

<p>一般来说</p>

<h3 id="析构函数">析构函数</h3>

<ul>
  <li>析构函数相当于 python 里的 <code class="language-plaintext highlighter-rouge">__del__</code></li>
  <li>析构函数的格式是 <code class="language-plaintext highlighter-rouge">类名::~类名</code></li>
  <li>每一个「拥有资源」的类都应该有析构函数</li>
</ul>

<p>写下了析构函数之后，当我们离开某一个 scope 后，这个 scope 里的对象会自动被执行析构函数。例子</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
    <span class="kt">double</span><span class="o">*</span> <span class="n">elem</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">{</span><span class="n">s</span><span class="p">},</span> <span class="n">elem</span><span class="p">{</span><span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">s</span><span class="p">]}</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span><span class="k">delete</span><span class="p">[]</span> <span class="n">elem</span><span class="p">;}</span>  <span class="c1">// 析构函数</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="n">Foo</span> <span class="n">f</span> <span class="p">{</span><span class="n">n</span><span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="cm">/*
    * 如果 Foo 没有实现析构函数，会消耗大量内存
    */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">func</span><span class="p">(</span><span class="mi">10000000</span><span class="p">);</span>
    <span class="p">}</span> <span class="c1">// 离开之后 func 内 Foo 实例占用的内存被自动释放</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="生成析构函数">生成析构函数</h3>

<p>如果某个类的「成员」有析构函数，那么这个类离开 scope 之后，这些「成员的析构函数」会被自动调用。这个行为被称为「编译器为这个类 生成 了一个析构函数」，所以这个不存在的析构函数被称为「生成析构函数」generated destructors。</p>

<p>例子，注意这段代码比上面的代码慢很多</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="n">Foo</span> <span class="n">f</span> <span class="p">{</span><span class="n">n</span><span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="cm">/*
    * Foo 没有实现析构函数，但没有内存泄漏
    */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">func</span><span class="p">(</span><span class="mi">10000000</span><span class="p">);</span>
    <span class="p">}</span> <span class="c1">// 离开之后 func 内 Foo.data 占用的内存被自动释放</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="指针-1">指针</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">类名 * 指针名</code> 会定义一个类的指针。</li>
  <li>如果我们想通过指针访问成员，我们需要 <code class="language-plaintext highlighter-rouge">指针名-&gt;成员</code></li>
</ul>

<h3 id="运算符重载">运算符重载</h3>

<p>我们可以自己定义运算符，它的格式是：</p>

<p><code class="language-plaintext highlighter-rouge">类名 operator 符号 (参数类型 参数名)</code></p>

<p>这个格式类似于函数的定义，只不过没有 <code class="language-plaintext highlighter-rouge">operator</code></p>

<p><code class="language-plaintext highlighter-rouge">返回数据类型 函数名 (参数类型 参数名)</code></p>

<h3 id="this">this</h3>

<p><code class="language-plaintext highlighter-rouge">this</code> 仅仅被用在「类的内部」（什么意思？），它表示指向「这个类的某个实例/对象」的指针。</p>

<p>它可以被用来检查参数是否是对象自己</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">FOO</span><span class="o">::</span><span class="n">is_self</span> <span class="p">(</span><span class="n">FOO</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">object</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="静态成员-static-member">静态成员 static member</h3>

<p>静态成员的内容不依赖于具体的对象/实例，它感觉像是「属于某个类的全局变量」</p>

<p>静态成员的格式是 <code class="language-plaintext highlighter-rouge">static 类型 变量名</code></p>

<p>为了避免静态成员被重复定义，静态成员的定义<strong>必须</strong>在类的定义之外。</p>

<p>例子：记录总共创建了多少实例</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">Foo</span><span class="p">()</span> <span class="p">{</span><span class="n">n</span><span class="o">++</span><span class="p">;};</span>
        <span class="o">~</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span><span class="n">n</span><span class="o">--</span><span class="p">;};</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">Foo</span><span class="o">::</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">Foo</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"there are "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">" instances of Foo"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="friend">Friend</h3>

<p>我们在定义类的时候，可以通过加上 <code class="language-plaintext highlighter-rouge">friend</code> 关键字来将「函数」或者「类」定义为 Friend。</p>

<p>Friend 可以访问该类的 <code class="language-plaintext highlighter-rouge">private</code> 或 <code class="language-plaintext highlighter-rouge">protected</code> 的内容。</p>

<p>例子 - friend 函数：<code class="language-plaintext highlighter-rouge">a_plus_one</code> 函数可以读写 <code class="language-plaintext highlighter-rouge">Foo</code> 的私有变量 <code class="language-plaintext highlighter-rouge">a</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="nl">private:</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">a_plus_one</span><span class="p">(</span><span class="n">Foo</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
    <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">show</span><span class="p">(){</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a is "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">a_plus_one</span><span class="p">(</span><span class="n">Foo</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">){</span>
    <span class="n">f</span><span class="p">.</span><span class="n">a</span> <span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
    <span class="n">a_plus_one</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>例子 - friend 类：<code class="language-plaintext highlighter-rouge">Bar</code> 的 <code class="language-plaintext highlighter-rouge">eat</code> 函数可以获取 <code class="language-plaintext highlighter-rouge">Foo</code> 的私有变量 <code class="language-plaintext highlighter-rouge">a</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="nl">private:</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">friend</span> <span class="k">class</span> <span class="nc">Bar</span><span class="p">;</span>
    <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">inc</span><span class="p">(){</span><span class="n">a</span><span class="o">++</span><span class="p">;}</span>
        <span class="kt">void</span> <span class="n">show</span><span class="p">(){</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a is "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">{</span>
    <span class="nl">private:</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">eat</span><span class="p">(</span><span class="n">Foo</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">){</span><span class="n">b</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">a</span><span class="p">;}</span>
        <span class="kt">void</span> <span class="n">show</span><span class="p">(){</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"b is "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">Bar</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
    <span class="n">f</span><span class="p">.</span><span class="n">inc</span><span class="p">();</span>
    <span class="n">b</span><span class="p">.</span><span class="n">eat</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="继承">继承</h3>

<p>C++ 中有子类的概念，子类继承父类的格式是 <code class="language-plaintext highlighter-rouge">class 字类名: 类型 父类名</code></p>

<p>C++ 中也可以多重继承，其格式是 <code class="language-plaintext highlighter-rouge">class 字类名: 类型 父类名#1 类型 父类名#2 ...</code></p>

<p>子类不会继承父类的构造函数和析构函数</p>

<p>其中，<code class="language-plaintext highlighter-rouge">类型</code> 包括 <code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">protected</code> 和 <code class="language-plaintext highlighter-rouge">public</code>。</p>

<p><code class="language-plaintext highlighter-rouge">protected</code> 下的方法 / 特性不能直接被成员调用，必须通过「这个类的子类的成员」来使用。</p>

<p>这里的 <code class="language-plaintext highlighter-rouge">类型</code> 的作用是保护从父类继承的成员（方法 &amp; 特性）。如果 <code class="language-plaintext highlighter-rouge">类型</code> 是 <code class="language-plaintext highlighter-rouge">private</code>，那么子类从父类继承的成员就是 <code class="language-plaintext highlighter-rouge">private</code></p>

<p><a href="https://stackoverflow.com/a/1372858">例子</a></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> 
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="nl">protected:</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="c1">// x is public</span>
    <span class="c1">// y is protected</span>
    <span class="c1">// z is not accessible from B</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">protected</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="c1">// x is protected</span>
    <span class="c1">// y is protected</span>
    <span class="c1">// z is not accessible from C</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">private</span> <span class="n">A</span>    <span class="c1">// 'private' is default for classes</span>
<span class="p">{</span>
    <span class="c1">// x is private</span>
    <span class="c1">// y is private</span>
    <span class="c1">// z is not accessible from D</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="虚函数">虚函数</h3>

<blockquote>
  <p>经验规则：如果一个 类 有虚函数，那么这个类需要一个 虚 析构函数</p>
</blockquote>

<p>我们可以在 基类 和 继承类 里定义「同名、同类型」的函数。这样的函数叫虚函数。实例使用的函数 来自的地方，是 基类 还是 继承类，在运行时决定。所以这个特性也叫 runtime polymorphism, dynamic dispatch, runtime dispatch。</p>

<p>使用虚函数的场景如下。有的时候我们创造了 抽象的基类，和许多不同的 派生类。这个时候我们想要写一个 函数 来 抽象地处理 所有的 派生类。这个时候我们的 函数 及其 调用 大概是这样</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="err">基类</span> <span class="o">&amp;</span> <span class="err">实例</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">实例</span><span class="p">.</span><span class="err">方法</span><span class="p">();</span>  <span class="c1">// 对于这个函数而言，它认为这个实例来自基类</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">func</span><span class="p">(</span><span class="err">派生类实例</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>此时，在函数 <code class="language-plaintext highlighter-rouge">func</code> 内部，函数认为它接受的 参数 是一个「基类的实例」。如果在 基类 里我们使用了 虚函数，那么 C++ 编译器就会自动在 <code class="language-plaintext highlighter-rouge">func</code> 内部的 <code class="language-plaintext highlighter-rouge">实例.方法()</code> 处调用 派生类 的方法。</p>

<p>下面是一个稍微具体一点的例子</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">struct</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"B"</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">count</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">D1</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"D1"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">1</span><span class="p">;}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">call</span><span class="p">(</span><span class="n">Base</span> <span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span>
    <span class="cm">/*
    * 因为 D1 派生于 Base 所以 call 也可以接受 D1 类实例
    * 如果 count 不是虚函数，那么 call 里 obj.count() 会返回 0
    */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"As Base, name: "</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">"; count : "</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">D1</span> <span class="n">d1</span><span class="p">;</span>
    <span class="n">call</span><span class="p">(</span><span class="n">d1</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"As D1, name: "</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">"; count: "</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="const-function">const function</h3>

<p><a href="https://stackoverflow.com/questions/3141087/what-is-meant-with-const-at-end-of-function-declaration">来源</a></p>

<p>有的时候我们能看到这样的代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> 
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">Bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">random_arg</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="c1">// code</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>这里面的 <code class="language-plaintext highlighter-rouge">const</code> 让我十分困惑：它为什么在这里？它的作用是什么？</p>

<p>当我们「使用」一个类的成员函数的时候，我们写出下面这样的代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>
<span class="n">f</span><span class="p">.</span><span class="n">Bar</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</code></pre></div></div>

<p>这等价于</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>
<span class="n">Foo_Bar</span><span class="p">(</span><span class="k">const</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<p>所以，<code class="language-plaintext highlighter-rouge">int Bar(int random_arg) const</code> 里的 <code class="language-plaintext highlighter-rouge">const</code> 保证了成员，或者说 <code class="language-plaintext highlighter-rouge">this</code> 是一个常量。这导致了 <code class="language-plaintext highlighter-rouge">Bar</code> 这个函数无法更改<strong>任何</strong>成员函数。</p>

<p>这样的函数叫 <code class="language-plaintext highlighter-rouge">const function</code></p>

<p>有的时候我们希望，一个成员变量永远能被改变，即使是 <code class="language-plaintext highlighter-rouge">const function</code>。这个时候我们用关键字 <code class="language-plaintext highlighter-rouge">mutable</code> 来修饰这个变量。</p>

<h2 id="其他话题">其他话题</h2>

<h3 id="头文件里放什么">头文件里放什么</h3>

<p>一个 C++ 的项目里 通常有很多 头文件 (<code class="language-plaintext highlighter-rouge">.h</code>, <code class="language-plaintext highlighter-rouge">.hpp</code> 甚至 <code class="language-plaintext highlighter-rouge">.tpp</code>) 和 代码文件 (<code class="language-plaintext highlighter-rouge">.cpp</code>)。什么东西应该被放进 头文件 (head file) 而什么应该被放进 代码文件 (code file) 呢？</p>

<p>我在 Stackoverflow 上看到了一个 <a href="https://stackoverflow.com/a/1945866">很优雅的答案</a>。简而言之，</p>

<ul>
  <li>在头文件里，我们放入「很多文件 共同需要的 信息」，即 <strong>抽象定义</strong>。</li>
  <li>在代码文件里，我们放入「只被这个文件需要的 信息」，即 <strong>具体实现</strong>。</li>
</ul>

<h3 id="map-的迭代">map 的迭代</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">std:map</code> 里，每个「元素的类型」是 <code class="language-plaintext highlighter-rouge">pair</code>，<code class="language-plaintext highlighter-rouge">pair.first</code> = 键；<code class="language-plaintext highlighter-rouge">pair.second</code> = 值。</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">std::map</code> 可以用</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">item</span> <span class="o">:</span> <span class="n">map_instance</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">;}</span>
</code></pre></div></div>
<p>的格式迭代。其中，<code class="language-plaintext highlighter-rouge">item</code> 的类型是 <a href="https://en.cppreference.com/w/cpp/utility/pair"><code class="language-plaintext highlighter-rouge">pair</code></a>。我们可以用 <code class="language-plaintext highlighter-rouge">item.first</code> 获取 键；用 <code class="language-plaintext highlighter-rouge">item.second</code> 获取 值。一个完整的例子如下</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;map&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"apple"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"orange"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">item</span> <span class="o">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="vector-作为-map-的键">vector 作为 map 的键</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">std::map</code> 里的「键 - 值」映射在创建的时候，内存里存放了完整的「键和值 的数值」。</p>
</blockquote>

<p>如果我创建了这样的数据结构</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>我个人比较担心的是，映射里的键 <code class="language-plaintext highlighter-rouge">std::vector&lt;int&gt;</code> 是怎么存储在 内存里的？具体而言，如果我用下面的代码 创建了 一个映射</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="n">m</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>这个时候, <code class="language-plaintext highlighter-rouge">m</code> 里有一个 键，它的类型是 <code class="language-plaintext highlighter-rouge">vector&lt;int&gt;</code>。但是我有点担心，它其实是指向 <code class="language-plaintext highlighter-rouge">vector&lt;int&gt;</code> 的一个指针。（因为 python 里基本上 <code class="language-plaintext highlighter-rouge">list</code> 和「指向 <code class="language-plaintext highlighter-rouge">list</code> 的指针」是一个意思）。这一段代码证明了，我的担心是多余的。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">m</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// m: {(1, 1, 1): 1}</span>
    <span class="n">a</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">m</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// m: {(1, 1, 1): 1, (2, 2, 2): 2}</span>
    <span class="n">a</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">// a 被清空之后，m 的键依然等于其他的 vector</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t2</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">[</span><span class="n">t1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// m[t1] -&gt; 1</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">[</span><span class="n">t2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// m[t2] -&gt; 2</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="vim-配置">Vim 配置</h3>

<p>我编写 C++ 代码的时候，习惯使用 vim 作为编辑器，搭配插件 <a href="https://github.com/dense-analysis/ale">ale</a> 和 <a href="https://github.com/ycm-core/YouCompleteMe">YouCompleteMe</a>。前者是作用是 检查代码语法，后者的作用是 代码的自动补全。在插件 <a href="https://github.com/dense-analysis/ale">ale</a> 进行 语法检查 的时候，我们需要「告诉」vim 我们的编译选项。由于 不同项目使用的 编译选项 不同，所以我倾向于 在不同项目下 使用不同的 vim 配置。具体的做法如下。</p>

<p>首先，向系统的 VIM 配置文件 (<code class="language-plaintext highlighter-rouge">vimrc</code>) 添加下面两行代码。大部分 Linux 系统下，这个文件处于 <code class="language-plaintext highlighter-rouge">$HOME/.vimrc</code> 或者 <code class="language-plaintext highlighter-rouge">$HOME/.vim/vimrc</code>。</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="nb">exrc</span>
<span class="k">set</span> <span class="nb">secure</span>
</code></pre></div></div>

<p>上面的 两行代码 能够让 vim 读取「当前的工作文件夹」下的 配置文件。其次，在 C++ 项目的文件夹（即，我们的工作文件夹）里，创建一个 命名为 <code class="language-plaintext highlighter-rouge">.vimrc</code> 的文件，加入下面的代码。</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">g:ale_linters</span> <span class="p">=</span> <span class="p">{</span><span class="s1">'cpp'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'clang'</span><span class="p">]}</span>  " use clang <span class="k">compiler</span>
<span class="k">let</span> cpp_flags <span class="p">=</span> <span class="s1">'-std=c++11 -Wall '</span>  " <span class="k">c</span><span class="p">++</span> standard &amp; show <span class="k">all</span> warnings
<span class="k">let</span> <span class="nv">g:ale_cpp_clang_options</span> <span class="p">=</span> cpp_flags  " <span class="k">set</span> the flag <span class="k">for</span> linting
</code></pre></div></div>

<p>我们可以在 <code class="language-plaintext highlighter-rouge">cpp_flags</code> 里加入更多的参数，来满足项目的需要。下面的 <code class="language-plaintext highlighter-rouge">.vimrc</code> 文件是我在使用 <code class="language-plaintext highlighter-rouge">Eigen</code> 库时使用的参数。</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">g:ale_linters</span> <span class="p">=</span> <span class="p">{</span><span class="s1">'cpp'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'clang'</span><span class="p">]}</span>  " use clang <span class="k">compiler</span>
<span class="k">let</span> cpp_flags <span class="p">=</span> <span class="s1">'-std=c++11 -Wall '</span>  " <span class="k">c</span><span class="p">++</span> standard &amp; show <span class="k">all</span> warnings
<span class="k">let</span> cpp_flags <span class="p">=</span> cpp_flags <span class="p">.</span> <span class="s1">'-I/usr/local/include/eigen3'</span> <span class="p">.</span> <span class="s1">' '</span>  " <span class="k">for</span> eigen
<span class="k">let</span> cpp_flags <span class="p">=</span> cpp_flags <span class="p">.</span> <span class="s1">'-Wno-unknown-warning-option'</span> <span class="p">.</span> <span class="s1">' '</span>  " supress eigen warnings
<span class="k">let</span> <span class="nv">g:ale_cpp_clang_options</span> <span class="p">=</span> cpp_flags  " <span class="k">set</span> the flag <span class="k">for</span> linting
</code></pre></div></div>


</div>


    </div>

  </body>

</html>
