<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>C++</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link rel="stylesheet" href="/assets/css/styles/github-gist.css">
    <script src="https://unpkg.com/lunr/lunr.js"></script>

    <script src="/assets/js/toc.js"></script>
    <script src="/assets/js/highlight.pack.js"></script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true
        }
      });
    </script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    </head>

  <body>
    <script>hljs.initHighlightingOnLoad();</script>


    <div id="side_bar">
    14 Apr 2021
</div>

<div class="center post">
    <ul id="markdown-toc">
  <li><a href="#参考资料" id="markdown-toc-参考资料">参考资料</a></li>
  <li><a href="#迭代" id="markdown-toc-迭代">迭代</a>    <ul>
      <li><a href="#传统循环" id="markdown-toc-传统循环">传统循环</a></li>
      <li><a href="#基于-stl-的迭代" id="markdown-toc-基于-stl-的迭代">基于 STL 的迭代</a></li>
    </ul>
  </li>
  <li><a href="#并发" id="markdown-toc-并发">并发</a>    <ul>
      <li><a href="#c11-并发功能" id="markdown-toc-c11-并发功能">C++11 并发功能</a></li>
      <li><a href="#c17-及以后" id="markdown-toc-c17-及以后">C++17 及以后</a></li>
      <li><a href="#线程-stdthread" id="markdown-toc-线程-stdthread">线程 <code class="language-plaintext highlighter-rouge">std::thread</code></a></li>
      <li><a href="#原子操作-stdatomic" id="markdown-toc-原子操作-stdatomic">原子操作 <code class="language-plaintext highlighter-rouge">std::atomic</code></a></li>
    </ul>
  </li>
  <li><a href="#函数" id="markdown-toc-函数">函数</a>    <ul>
      <li><a href="#lambda-函数" id="markdown-toc-lambda-函数">Lambda 函数</a></li>
      <li><a href="#在不同源代码中共享函数" id="markdown-toc-在不同源代码中共享函数">在不同源代码中共享函数</a></li>
      <li><a href="#传递指针给函数" id="markdown-toc-传递指针给函数">传递指针给函数</a></li>
      <li><a href="#没有变量名的参数" id="markdown-toc-没有变量名的参数">没有变量名的参数</a></li>
    </ul>
  </li>
  <li><a href="#内存" id="markdown-toc-内存">内存</a>    <ul>
      <li><a href="#动态内存分配" id="markdown-toc-动态内存分配">动态内存分配</a></li>
      <li><a href="#指针不知道内存的长度" id="markdown-toc-指针不知道内存的长度">指针不知道内存的长度</a></li>
      <li><a href="#自定义类型的内存分配" id="markdown-toc-自定义类型的内存分配">自定义类型的内存分配</a></li>
      <li><a href="#内存分页" id="markdown-toc-内存分页">内存分页</a></li>
      <li><a href="#valgrind" id="markdown-toc-valgrind">Valgrind</a></li>
    </ul>
  </li>
  <li><a href="#深入多态" id="markdown-toc-深入多态">深入多态</a>    <ul>
      <li><a href="#编译时多态" id="markdown-toc-编译时多态">编译时多态</a></li>
      <li><a href="#运行时多态" id="markdown-toc-运行时多态">运行时多态</a></li>
    </ul>
  </li>
  <li><a href="#指针" id="markdown-toc-指针">指针</a>    <ul>
      <li><a href="#声明" id="markdown-toc-声明">声明</a></li>
      <li><a href="#null-指针" id="markdown-toc-null-指针"><code class="language-plaintext highlighter-rouge">null</code> 指针</a></li>
      <li><a href="#this-指针" id="markdown-toc-this-指针"><code class="language-plaintext highlighter-rouge">this</code> 指针</a></li>
    </ul>
  </li>
  <li><a href="#智能指针" id="markdown-toc-智能指针">智能指针</a>    <ul>
      <li><a href="#独占指针unique-pointer" id="markdown-toc-独占指针unique-pointer">独占指针（Unique Pointer）</a></li>
      <li><a href="#共享指针shared-pointer" id="markdown-toc-共享指针shared-pointer">共享指针（Shared Pointer）</a></li>
      <li><a href="#弱指针weak-pointer" id="markdown-toc-弱指针weak-pointer">弱指针（Weak Pointer）</a></li>
    </ul>
  </li>
  <li><a href="#面向对象" id="markdown-toc-面向对象">面向对象</a>    <ul>
      <li><a href="#结构体和类" id="markdown-toc-结构体和类">结构体和类</a></li>
      <li><a href="#访问修饰符" id="markdown-toc-访问修饰符">访问修饰符</a></li>
      <li><a href="#运算符的读法" id="markdown-toc-运算符的读法">运算符的读法</a></li>
      <li><a href="#构造函数" id="markdown-toc-构造函数">构造函数</a></li>
      <li><a href="#析构函数" id="markdown-toc-析构函数">析构函数</a></li>
      <li><a href="#运算符重载" id="markdown-toc-运算符重载">运算符重载</a></li>
      <li><a href="#静态成员" id="markdown-toc-静态成员">静态成员</a></li>
      <li><a href="#继承" id="markdown-toc-继承">继承</a></li>
      <li><a href="#虚函数" id="markdown-toc-虚函数">虚函数</a></li>
    </ul>
  </li>
  <li><a href="#修饰符" id="markdown-toc-修饰符">修饰符</a>    <ul>
      <li><a href="#修饰符类别" id="markdown-toc-修饰符类别">修饰符类别</a></li>
      <li><a href="#static" id="markdown-toc-static"><code class="language-plaintext highlighter-rouge">static</code></a></li>
      <li><a href="#const" id="markdown-toc-const"><code class="language-plaintext highlighter-rouge">const</code></a></li>
      <li><a href="#inline" id="markdown-toc-inline"><code class="language-plaintext highlighter-rouge">inline</code></a></li>
    </ul>
  </li>
  <li><a href="#优化" id="markdown-toc-优化">优化</a>    <ul>
      <li><a href="#汇编代码" id="markdown-toc-汇编代码">汇编代码</a></li>
      <li><a href="#线性访问" id="markdown-toc-线性访问">线性访问</a></li>
    </ul>
  </li>
  <li><a href="#其他话题" id="markdown-toc-其他话题">其他话题</a>    <ul>
      <li><a href="#最令人困惑的解析" id="markdown-toc-最令人困惑的解析">最令人困惑的解析</a></li>
      <li><a href="#头文件里放什么" id="markdown-toc-头文件里放什么">头文件里放什么</a></li>
      <li><a href="#stdmap" id="markdown-toc-stdmap">std::map</a></li>
      <li><a href="#vim-配置" id="markdown-toc-vim-配置">Vim 配置</a></li>
    </ul>
  </li>
</ul>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://ppc.cs.aalto.fi/">Programming Parallel Computers</a></li>
  <li><a href="https://www.coursera.org/specializations/cs-fundamentals">Accelerated Computer Science Fundamentals Specialization</a></li>
</ul>

<h2 id="迭代">迭代</h2>

<p>迭代是编程中的基础概念，而 C++ 提供了许多技术来迭代集合，每种技术都有其细微差别和用例。</p>

<h3 id="传统循环">传统循环</h3>

<p><strong>基本的 For 循环</strong>：当迭代次数事先已知时常用。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 访问 vec[i]</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>While 和 Do-While 循环</strong>：当迭代次数不是由索引严格定义，或者循环至少必须运行一次时使用。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// While 循环</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 访问 vec[i]</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Do-While 循环</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="c1">// 访问 vec[j]</span>
    <span class="o">++</span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</code></pre></div></div>

<p><strong>基于指针的迭代</strong>：直接访问内存，通常与 C 风格的数组一起使用。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">arr</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 访问 *p</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="基于-stl-的迭代">基于 STL 的迭代</h3>

<p><strong>基于迭代器的 For 循环</strong>：使用容器定义的迭代器直接访问元素。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 访问 *it</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>基于范围的 For 循环</strong>：C++11 引入，用于简化容器遍历。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">value</span> <span class="o">:</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 访问 value</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>使用函数指针和仿函数的 <code class="language-plaintext highlighter-rouge">std::for_each</code></strong>：在 C++11 的 lambda 函数之前，这些是常用的方法。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用函数指针</span>
<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">process</span><span class="p">);</span>

<span class="c1">// 使用仿函数</span>
<span class="k">struct</span> <span class="nc">MyFunctor</span> <span class="p">{</span>
   <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
       <span class="c1">// 处理 value</span>
   <span class="p">}</span>
<span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">MyFunctor</span><span class="p">());</span>
</code></pre></div></div>

<p><strong>使用 Lambda 的 <code class="language-plaintext highlighter-rouge">std::for_each</code></strong>：C++11 之后，lambda 函数提供了一种更简洁的使用 <code class="language-plaintext highlighter-rouge">std::for_each</code> 的方式。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 处理 value</span>
<span class="p">});</span>
</code></pre></div></div>

<p><strong>带迭代器的算法</strong>：<code class="language-plaintext highlighter-rouge">&lt;algorithm&gt;</code> 中的 STL 算法在迭代器范围上操作。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 示例：std::transform</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="p">});</span>
</code></pre></div></div>

<p><strong>并行迭代</strong>：C++17 引入了并行算法，用于多线程处理。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">process</span><span class="p">);</span>
</code></pre></div></div>

<p>虽然传统的循环机制仍然是相关的，尤其是对于更简单的任务或与内存紧密合作时，基于 STL 的技术提供了强大、表现力强和通常更易读的方式来迭代集合。选择技术应由任务的具体要求、所需的代码清晰度和性能考虑来驱动。</p>

<h2 id="并发">并发</h2>

<p>并发涉及设计和构建系统来管理多个任务，这些任务可能重叠或交错。C++ 的发展显著地增加了并发支持功能。</p>

<ul>
  <li><strong>并发</strong>: 针对多个任务的设计中心管理。 It’s more about managing many things at once.</li>
  <li><strong>并行</strong>: 任务执行以提高性能。It’s about doing many things at once.</li>
</ul>

<p>C++11 之前，标准库</p>

<ul>
  <li>缺少内置并发支持。</li>
  <li>依赖于特定平台的库或 <code class="language-plaintext highlighter-rouge">Boost.Thread</code>。</li>
</ul>

<h3 id="c11-并发功能">C++11 并发功能</h3>

<p><strong>内存模型</strong>: 使多线程场景下的内存行为易于理解。</p>

<p><strong>线程 (<code class="language-plaintext highlighter-rouge">&lt;thread&gt;</code>)</strong>: 提供直接、可访问的方法在不同线程中运行函数。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">print_hello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"来自另一个线程的问候！"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">print_hello</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"来自主线程的问候！"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>互斥体 (<code class="language-plaintext highlighter-rouge">&lt;mutex&gt;</code>)</strong>: 保证数据完整性，避免数据竞争。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">shared_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="o">++</span><span class="n">shared_data</span><span class="p">;</span>
        <span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"共享数据值: "</span> <span class="o">&lt;&lt;</span> <span class="n">shared_data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>条件变量 (<code class="language-plaintext highlighter-rouge">&lt;condition_variable&gt;</code>)</strong>: 基于特定条件同步线程。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">ready</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">print_message</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[]{</span> <span class="k">return</span> <span class="n">ready</span><span class="p">;</span> <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"来自工作线程的问候！"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">print_message</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"设置就绪标志..."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
        <span class="n">ready</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>原子操作 (<code class="language-plaintext highlighter-rouge">&lt;atomic&gt;</code>)</strong>: 对共享数据进行无锁操作。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"计数值: "</span> <span class="o">&lt;&lt;</span> <span class="n">count</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>未来 (<code class="language-plaintext highlighter-rouge">&lt;future&gt;</code>)</strong>: 异步运行函数并稍后检索结果。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">compute</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span> <span class="o">*</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">compute</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"执行其他任务..."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"结果: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="c17-及以后">C++17 及以后</h3>

<p><strong>并行算法</strong>: 无需手动线程管理即可获得最佳性能。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>并发 TS 和协程</strong>: 线性、可读的异步代码。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 注意: 实际使用可能需要编译器和标准库对协程的支持。</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;coroutine&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">compute</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">co_return</span> <span class="mi">42</span> <span class="o">*</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">compute</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"结果: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="线程-stdthread">线程 <code class="language-plaintext highlighter-rouge">std::thread</code></h3>

<p><code class="language-plaintext highlighter-rouge">std::thread</code> 是 C++11 中引入的标准库类，用于管理线程。它允许代码并行执行。在 C++11 之前，通常使用平台特定的库或第三方库来实现线程。</p>

<ul>
  <li><strong>构造函数</strong>：通过为 <code class="language-plaintext highlighter-rouge">std::thread</code> 的构造函数提供一个函数（或可调用的对象）来启动一个新线程。这个线程将立即开始执行所提供的函数。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">myThread</span><span class="p">(</span><span class="n">functionName</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><strong>join()</strong>：用于等待线程完成其执行的方法。当你调用 <code class="language-plaintext highlighter-rouge">join()</code> 时，调用线程（通常是主线程）将阻塞，直到 <code class="language-plaintext highlighter-rouge">std::thread</code> 对象完成其执行。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div>

<ul>
  <li><strong>detach()</strong>：此方法允许线程在后台运行，让调用线程继续执行，而无需等待分离的线程完成。一旦线程被分离，它完成执行后，其资源将自动被释放。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myThread</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</code></pre></div></div>

<p>当使用 <code class="language-plaintext highlighter-rouge">detach()</code> 方法时，必须小心。如果一个分离的线程访问已经被销毁的资源，它会导致未定义的行为。
这种情况是多线程编程中的一个常见陷阱，被称为“竞态条件” (race condition) 。</p>

<p>示例:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">someFunction</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">someLocalVariable</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">someLocalVariable</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 危险!</span>
    <span class="p">});</span>

    <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
<span class="p">}</span>  <span class="c1">// 这里 someLocalVariable 超出范围并被销毁</span>
</code></pre></div></div>

<p>在上述示例中，分离的线程在 <code class="language-plaintext highlighter-rouge">someLocalVariable</code> 被销毁后尝试访问它，导致未定义的行为。</p>

<ul>
  <li><strong>joinable()</strong>：检查线程是否可连接。如果线程仍在运行且尚未被连接或分离，那么线程是可连接的。在其 <code class="language-plaintext highlighter-rouge">std::thread</code> 对象被销毁之前，必须连接或分离一个可连接的线程，以防止程序终止。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">myThread</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">myThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong>hardware_concurrency()</strong>：返回一个估计的数字，表示系统可以并行运行的线程数。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
</code></pre></div></div>

<p>使用线程时，重要的考虑因素:</p>

<ol>
  <li>总是确保在其关联的 <code class="language-plaintext highlighter-rouge">std::thread</code> 对象被销毁之前，要么 <code class="language-plaintext highlighter-rouge">join</code> 线程，要么 <code class="language-plaintext highlighter-rouge">detach</code> 线程，以防止程序终止。</li>
  <li>当多个线程访问共享数据时，同步是至关重要的。使用 <code class="language-plaintext highlighter-rouge">std::mutex</code> 等同步机制来防止竞态条件并确保数据的一致性。</li>
  <li>理解线程和它们访问的资源的生命周期是至关重要的。线程访问已销毁的资源可能导致未定义的行为和潜在的程序崩溃。</li>
  <li>在多线程环境中使用线程安全的数据结构和实用程序以获得更好的安全性。</li>
</ol>

<h3 id="原子操作-stdatomic">原子操作 <code class="language-plaintext highlighter-rouge">std::atomic</code></h3>

<p>在多线程程序中，<code class="language-plaintext highlighter-rouge">std::atomic</code> 为变量提供了原子（不可中断）操作，以防止在并发上下文中的数据竞争。</p>

<p><strong>基本原子操作</strong>：<code class="language-plaintext highlighter-rouge">std::atomic</code> 的主要用途是保证对封装的变量进行原子操作。这包括赋值、读取、增加等操作。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">counter</span><span class="o">++</span><span class="p">;</span>       <span class="c1">// 原子增加</span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">counter</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>  <span class="c1">// 原子读取</span>
</code></pre></div></div>

<p>对于非原子变量，我们需要用 mutex 保护它，来达到 thread-safe.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">atomicCount</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nonAtomicCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">process</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">atomicCount</span><span class="p">;</span>

    <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="o">++</span><span class="n">nonAtomicCount</span><span class="p">;</span>
    <span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>内存顺序</strong>：<code class="language-plaintext highlighter-rouge">std::atomic</code> 提供了控制操作的内存顺序的更高级特性。这允许开发者在特定场景中优化线程之间的同步。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">counter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>复杂原子操作</strong>：除基本操作外，<code class="language-plaintext highlighter-rouge">std::atomic</code> 提供了更复杂的原子操作，如 <code class="language-plaintext highlighter-rouge">compare_exchange_weak</code> 和 <code class="language-plaintext highlighter-rouge">compare_exchange_strong</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">expected</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">atomicVar</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>原子标志</strong>：<code class="language-plaintext highlighter-rouge">std::atomic_flag</code> 是一个专门的原子类型，作为一个自旋锁。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">atomic_flag</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">ATOMIC_FLAG_INIT</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">.</span><span class="n">test_and_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span>  <span class="c1">// 自旋直到标志清除</span>
<span class="c1">// 临界区</span>
<span class="n">flag</span><span class="p">.</span><span class="n">clear</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>专门的原子类型</strong>：C++ 标准库为整数、指针和其他常见类型提供了专门的原子类型，如 <code class="language-plaintext highlighter-rouge">std::atomic_int</code>, <code class="language-plaintext highlighter-rouge">std::atomic_long</code>, <code class="language-plaintext highlighter-rouge">std::atomic_bool</code> 和 <code class="language-plaintext highlighter-rouge">std::atomic&lt;void*&gt;</code>。</p>

<p>总之，<code class="language-plaintext highlighter-rouge">std::atomic</code> 不仅仅是改变变量的行为，它提供了丰富的特性，允许开发者创建精密的多线程算法和数据结构。</p>

<h2 id="函数">函数</h2>

<h3 id="lambda-函数">Lambda 函数</h3>

<p>Lambda 函数在 C++11 中被引入，它提供了一种简洁的方式直接在函数体或类方法中定义匿名（无名）函数。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">capture_clause</span><span class="p">](</span><span class="err">参数</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="err">返回类型</span> <span class="p">{</span>
    <span class="c1">// lambda 函数体</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong>capture_clause</strong>: 指定哪些外部变量对于 lambda 是可用的。</li>
  <li><strong>参数</strong>: 像常规函数参数一样。</li>
  <li><strong>返回类型</strong>: 通常由编译器自动推导，但可以明确指定。</li>
  <li><strong>函数体</strong>: 当调用 lambda 时要执行的代码。</li>
</ul>

<p>使用<strong>捕获子句 (capture clause)</strong> 可以使来自封闭作用域的变量在 lambda 内部可用。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">[=]</code>: 通过值捕获所有本地变量。</li>
  <li><code class="language-plaintext highlighter-rouge">[&amp;]</code>: 通过引用捕获所有本地变量。</li>
  <li><code class="language-plaintext highlighter-rouge">[x, &amp;y]</code>: 通过值捕获 <code class="language-plaintext highlighter-rouge">x</code> 并通过引用捕获 <code class="language-plaintext highlighter-rouge">y</code>。</li>
</ul>

<h3 id="在不同源代码中共享函数">在不同源代码中共享函数</h3>

<p><a href="https://stackoverflow.com/a/25274411">参考链接</a></p>

<p>如果我们想要在我们的「项目」下的「不同源代码」里共用一个函数，我们可以通过下面的三个步骤完成</p>

<p>1 - 将函数的定义写进「头文件」</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef FUNCTIONS_H_INCLUDED
#define FUNCTIONS_H_INCLUDED
</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// Function prototype, its declaration</span>

<span class="cp">#endif
</span></code></pre></div></div>

<p>（其中的 <code class="language-plaintext highlighter-rouge">#ifndef</code> 之类的东西叫做 <a href="https://en.wikipedia.org/wiki/Include_guard">include gard</a>，用来避免 重复引用头文件 造成的 对同一个函数的 多次定义。注意，include gard 只在「同一个」.cpp 源文件内起作用。）</p>

<p>2 - 在「第一个」源文件里定义函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"functions.h"</span><span class="cp">
</span>
<span class="c1">// Function definition</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>3 - 在「其他源文件」中 <code class="language-plaintext highlighter-rouge">include</code> 头文件，使用函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">"functions.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"add(1, 2) = "</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="传递指针给函数">传递指针给函数</h3>

<p>在 C 语言里，传递指针（譬如 <code class="language-plaintext highlighter-rouge">*num</code>）的语法如下：</p>

<pre><code class="language-C">void triple(int *num) {
    *num = *num * 3;
}
</code></pre>

<p>C++ 里可以做同样的事情，不过也可以传递<strong>地址</strong>（譬如 <code class="language-plaintext highlighter-rouge">&amp;num</code>）</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">triple</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="没有变量名的参数">没有变量名的参数</h3>

<p>在某些特殊的情况下，我们会写出下面的函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">one</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>这个函数 的输入 是一个小数，输出 永远为 1.0。此时，输入的参数 并不会进入 实际的计算，所以我么不需要给它 变量名。</p>

<h2 id="内存">内存</h2>

<p>在 C++ 中，内存通常分为四个段：</p>

<ul>
  <li>栈（Stack）：用于自动变量和函数调用信息。</li>
  <li>堆（Heap）：用于动态分配的内存。</li>
  <li>数据段（Data Segment）：用于全局和静态变量。</li>
  <li>代码段（Code Segment）：用于可执行代码。</li>
</ul>

<h3 id="动态内存分配">动态内存分配</h3>

<p>在 C++ 中，使用 <code class="language-plaintext highlighter-rouge">new</code> 关键字从堆中分配内存。例如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</code></pre></div></div>

<p>你也可以使用变量来动态指定数组的大小：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</code></pre></div></div>

<p>初始化堆内存中的数组也是可能的：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</code></pre></div></div>

<p>动态分配的内存需要手动释放，以防止内存泄漏（Memory Leak）。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">delete</span> <span class="n">p</span>    <span class="c1">// 释放单个对象</span>
<span class="k">delete</span><span class="p">[]</span> <span class="n">p</span>  <span class="c1">// 释放对象数组</span>
</code></pre></div></div>

<p>如果不释放内存，程序可能会消耗所有可用内存，最终被操作系统终止。</p>

<h3 id="指针不知道内存的长度">指针不知道内存的长度</h3>

<p>使用 <code class="language-plaintext highlighter-rouge">new</code> 分配的内存，会返回一个指针，但该指针不包含关于分配内存大小的信息。这可能导致越界访问（Out-of-Range Access），这是一种常见的、难以调试的错误。譬如，</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<p>在 heap 区域里分配了 2 个 <code class="language-plaintext highlighter-rouge">double</code> 占用的内存，并且返回一个指向这一小块内存的指针 <code class="language-plaintext highlighter-rouge">p</code>。但是，指针<strong>不知道</strong>自己指向的内存的长度。我们可以通过 <code class="language-plaintext highlighter-rouge">p</code> 访问我们不应该访问的内存。</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="bp">...</span>
</code></pre></div></div>

<p>一个避免 out-of-range access 的方法是使用 <code class="language-plaintext highlighter-rouge">vector</code>。</p>

<h3 id="自定义类型的内存分配">自定义类型的内存分配</h3>

<p>对于具有默认构造函数的自定义类型 <code class="language-plaintext highlighter-rouge">X</code>：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">X</span><span class="o">*</span> <span class="n">px1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">X</span><span class="p">;</span>       <span class="c1">// 单个实例</span>
<span class="n">X</span><span class="o">*</span> <span class="n">px2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">X</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>   <span class="c1">// 数组</span>
</code></pre></div></div>

<p>对于没有默认构造函数的自定义类型 <code class="language-plaintext highlighter-rouge">Y</code>：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Y</span><span class="o">*</span> <span class="n">py1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Y</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>            <span class="c1">// 单个实例</span>
<span class="n">Y</span><span class="o">*</span> <span class="n">py2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Y</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>  <span class="c1">// 数组</span>
</code></pre></div></div>

<h3 id="内存分页">内存分页</h3>

<p>内存分页是一种内存管理方案，主要用于虚拟内存系统。在这种方案中，物理内存被划分为固定大小的块，称为<strong>页（pages）</strong>。同样地，虚拟内存也被划分为相同大小的页。操作系统维护一个<strong>页表（page table）</strong>来映射<strong>虚拟页</strong>到<strong>物理页</strong>。</p>

<p>内存分页有下面的好处，</p>

<ol>
  <li><strong>内存保护</strong>: 分页允许操作系统为每个进程提供独立的地址空间，从而实现内存隔离。</li>
  <li><strong>动态内存分配</strong>: 分页简化了内存分配，使得小块内存可以更容易地被分配和回收。</li>
  <li><strong>虚拟内存</strong>: 通过分页，操作系统可以使用磁盘空间作为虚拟内存，从而扩展可用的内存空间。</li>
</ol>

<p>当程序访问一个<strong>虚拟地址</strong>时，硬件和操作系统会一起查找相应的<strong>页表</strong>，以确定该虚拟地址对应的物理地址。这个过程称为<strong>页转换（page translation）</strong>。</p>

<p>虽然分页主要是操作系统级别的概念，了解它对于理解如何优化 C++ 程序以减少“页面错误（page faults）”是有用的。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">largeVector</span><span class="p">(</span><span class="mf">1e6</span><span class="p">);</span>  <span class="c1">// 特别大的数组</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">largeVector</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">largeVector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// 页面错误可能在这里发生,导致性能下降</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="valgrind">Valgrind</h3>

<p>Valgrind 是一个开源的内存调试、内存泄漏检测和性能分析工具。它最初由 Julian Seward 开发，并于 2000 年首次发布。该工具主要用于 Linux 和 macOS 系统，尽管也有一些不太成熟的 Windows 版本。它包含下面的功能，</p>

<ol>
  <li><strong>内存泄漏检测</strong>: Valgrind 的 Memcheck 工具可以检测内存泄漏、未初始化的内存访问以及其他内存相关错误。</li>
  <li><strong>性能分析</strong>: 使用 Cachegrind 和 Callgrind 工具，您可以分析代码的缓存使用和调用图。</li>
  <li><strong>并发错误检测</strong>: Helgrind 和 DRD 工具用于检测多线程程序中的数据竞争条件。</li>
</ol>

<p><strong>基本使用</strong>: 使用 Valgrind 运行 C++ 程序通常如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind ./your_program
</code></pre></div></div>

<p><strong>检查内存泄漏</strong>: 使用 Memcheck 工具：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind <span class="nt">--tool</span><span class="o">=</span>memcheck ./your_program
</code></pre></div></div>

<p><strong>性能分析</strong>: 使用 Cachegrind 工具：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind <span class="nt">--tool</span><span class="o">=</span>cachegrind ./your_program
</code></pre></div></div>

<p>Valgrind 是一个非常强大的工具，对于内存调试和性能分析非常有用。了解其基本用法和功能可以帮助您更有效地进行 C++ 开发。</p>

<h2 id="深入多态">深入多态</h2>

<p>多态是面向对象编程中的一个核心概念，它允许对象被当作其父类的实例，而不是它们实际的类。在 C++ 中，有两种类型的多态：编译时（静态）多态和运行时（动态）多态。</p>

<h3 id="编译时多态">编译时多态</h3>

<p>编译时多态在编译过程中通过诸如函数重载、操作符重载和模板等机制得到解决。编译器根据参数类型和参数数量确定适当的函数调用。函数重载示例如下</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"打印整数: "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">double</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"打印浮点数: "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="运行时多态">运行时多态</h3>

<p>运行时多态通过继承和虚函数实现。它允许一个函数根据函数正在操作的实际对象的类型来执行不同的操作。下面的代码展示了基类和派生类示例</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"某种动物的声音"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cat</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"喵"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>当你创建一个 <code class="language-plaintext highlighter-rouge">Cat</code> 对象并将其当作 <code class="language-plaintext highlighter-rouge">Animal</code> 对待时，会调用 <code class="language-plaintext highlighter-rouge">Cat</code> 的 <code class="language-plaintext highlighter-rouge">speak</code> 方法，演示了运行时多态。</p>

<p>派生类的内存布局在开始处包含基类的布局，这允许基类指针正确地引用派生类对象。内存布局如下面的 ASCII 图所示</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Cat* ptr = new Cat();

+------------------+ 
|   Animal 部分    | &lt;- ptr 指向这部分的开始
|------------------|
| - Animal 数据    | &lt;- 基类数据成员
+------------------+
|   Cat 部分       | 
|------------------|
| - Cat 数据       | &lt;- 派生类数据成员
+------------------+
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ptr</code> 指向 <code class="language-plaintext highlighter-rouge">Cat</code> 对象的开始，这包括 <code class="language-plaintext highlighter-rouge">Animal</code> 部分，因为派生类对象的布局是以基类的布局开始的。</p>

<p>虚函数表用于在运行时解决函数调用。每个有虚函数的类都有自己的 vtable，如下面的 ASCII 图所示</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+------------------+
|   Animal 类的    | 
|   vtable         | 
+------------------+
| Animal::speak()  | &lt;- 指向 Animal 的 speak 函数
+------------------+

+------------------+
|   Cat 类的       | 
|   vtable         | 
+------------------+
| Cat::speak()     | &lt;- 指向 Cat 重写的 speak 函数
+------------------+
</code></pre></div></div>

<p>这个 vtable 机制确保了基于对象的实际类型调用正确的函数。</p>

<h2 id="指针">指针</h2>

<ul>
  <li>声明指向类型的指针 <code class="language-plaintext highlighter-rouge">类型 * 指针名</code></li>
  <li>获取指针的内容 (dereference) <code class="language-plaintext highlighter-rouge">* 指针名</code></li>
  <li>我们也可以用 <code class="language-plaintext highlighter-rouge">指针名[位移]</code> 来取得地址的内容，<code class="language-plaintext highlighter-rouge">[]</code> 叫 subscript operator。</li>
  <li><code class="language-plaintext highlighter-rouge">指针名[0]</code> 等价于 <code class="language-plaintext highlighter-rouge">* 指针名</code></li>
  <li>获取一个对象的地址 <code class="language-plaintext highlighter-rouge">&amp; 对象名</code>，<code class="language-plaintext highlighter-rouge">&amp;</code> 叫 address of operator</li>
  <li>声明<strong>类的指针</strong>：<code class="language-plaintext highlighter-rouge">ClassName * pointerName</code>。</li>
  <li>通过指针访问成员：<code class="language-plaintext highlighter-rouge">pointerName-&gt;member</code>。</li>
</ul>

<p>使用 <code class="language-plaintext highlighter-rouge">sizeof</code> 函数可以获取 不同对象/指针 占用的内存，下面是一些结果</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">uint8_t:</span>  <span class="mi">1</span>  <span class="c1">// 数据占用的内存</span>
<span class="kt">double</span><span class="o">:</span>   <span class="mi">8</span>  <span class="c1">// 数据占用的内存</span>
<span class="o">*</span><span class="kt">uint8_t</span><span class="o">:</span> <span class="mi">8</span>  <span class="c1">// 指针占用的内存</span>
<span class="o">*</span><span class="kt">double</span><span class="o">:</span>  <span class="mi">8</span>  <span class="c1">// 指针占用的内存</span>
</code></pre></div></div>

<h3 id="声明">声明</h3>

<p>我们可以先「给一个变量赋值」，再「得到指向这个变量的指针」</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果我们想要「先创建一个指针」，接着「给指针指向的内存赋值」，直觉上我们会写出这样的代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这段代码一定不会编译成功</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pa</span><span class="p">;</span>  <span class="c1">// 没有初始化，得到一个随机地址；这样的代码永远不应该出现</span>
    <span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的代码首先生成了一个「随机的地址」，之后向这个地址写入了 <code class="language-plaintext highlighter-rouge">1</code>。这样是不对的，因为我们有可能改变程序里其他对象的值。</p>

<p>不过，如果我们主动声明「指针指向的变量」，即确定「指针的地址」，那么我们就可以给这个地址赋值了。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 可以编译成功</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pa</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>还有一种方法是使用 <code class="language-plaintext highlighter-rouge">new</code> 主动分配内存</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// 得到一个 heap 里的随机地址</span>
    <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="null-指针"><code class="language-plaintext highlighter-rouge">null</code> 指针</h3>

<p>如果我们在 创建指针的时候 暂时没有一个「用于初始化」的地址，那么我们<strong>应该</strong>用 <code class="language-plaintext highlighter-rouge">nullptr</code> 来 初始化这个指针</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="o">*</span> <span class="n">p0</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
</code></pre></div></div>

<p>这会将 <code class="language-plaintext highlighter-rouge">p0</code> 的地址设定为 <code class="language-plaintext highlighter-rouge">0x0</code>。</p>

<p>此外，不同的编译器 对于 没有初始化的指针 有不同的处理。苹果的 <code class="language-plaintext highlighter-rouge">clang11</code> 会将 没有初始化的指针 自动设置为 <code class="language-plaintext highlighter-rouge">nummptr</code> 但是 <code class="language-plaintext highlighter-rouge">g++9.2</code> 不会。</p>

<p>我们可以用 下面两种方法 判断 指针 是否属于 <code class="language-plaintext highlighter-rouge">nullptr</code>；我们会这么做的原因是，有的时候我们需要 构建一个指针——它在 某种情况下 有效，指向某个地址；在 另外的情况下 无效，指向 <code class="language-plaintext highlighter-rouge">nullptr</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>  <span class="c1">// 第一种</span>
<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// 第二种，推荐</span>
</code></pre></div></div>

<h3 id="this-指针"><code class="language-plaintext highlighter-rouge">this</code> 指针</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this</code>只能在类的成员函数内部使用。</li>
  <li><code class="language-plaintext highlighter-rouge">this</code>是一个指向当前对象的指针。</li>
</ul>

<p>示例</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">FOO</span><span class="o">::</span><span class="n">is_self</span> <span class="p">(</span><span class="n">FOO</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">object</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="智能指针">智能指针</h2>

<ul>
  <li>C++中的智能指针允许在不使用<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>的情况下使用指针。</li>
  <li>需要包含头文件：<code class="language-plaintext highlighter-rouge">&lt;memory&gt;</code></li>
  <li>智能指针的类型：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">std::unique_ptr</code></li>
      <li><code class="language-plaintext highlighter-rouge">std::shared_ptr</code></li>
      <li><code class="language-plaintext highlighter-rouge">std::weak_ptr</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">std::unique_ptr</code>更受欢迎因为它的开销较小，但需要小心管理作用域。</li>
</ul>

<h3 id="独占指针unique-pointer">独占指针（Unique Pointer）</h3>

<p>管理单个对象，并在指针超出作用域时自动销毁对象。构建 unique pointer 的代码如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">e</span><span class="p">(</span><span class="k">new</span> <span class="nf">E</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// protect against exception</span>
</code></pre></div></div>

<p>其中，当我们直接使用 <code class="language-plaintext highlighter-rouge">new</code> 创建 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 时，实际上进行了两个步骤：</p>

<ol>
  <li>为 <code class="language-plaintext highlighter-rouge">E</code> 分配内存。</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">E</code> 的构造函数。</li>
</ol>

<p>如果我们的程序在</p>

<ol>
  <li>内存分配之后、构造函数调用之前，或</li>
  <li>构造函数调用期间</li>
</ol>

<p>抛出异常，会导致内存泄漏，因为分配的内存尚未分配给智能指针。相比之下，<code class="language-plaintext highlighter-rouge">std::make_unique</code> 在单个操作中处理分配和构造。如果在此过程中发生异常，<code class="language-plaintext highlighter-rouge">std::make_unique</code> 将自动清理（即释放）内存，从而防止内存泄漏。换言之，因为<strong>内存分配</strong>和<strong>构造函数调用</strong>被封装在同一个原子操作内，所以没有<strong>间隙</strong>可以让异常留下<strong>未被智能指针管理的已分配内存</strong>。</p>

<h3 id="共享指针shared-pointer">共享指针（Shared Pointer）</h3>

<p>通过引用计数来管理对象，有轻微的内存开销。 <strong>示例</strong>：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">e1</span><span class="p">;</span> <span class="c1">// e1 和 e2 管理同一个对象</span>
</code></pre></div></div>

<h3 id="弱指针weak-pointer">弱指针（Weak Pointer）</h3>

<p>复制<code class="language-plaintext highlighter-rouge">shared_ptr</code>但不增加引用计数。 <strong>示例</strong>：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span> <span class="n">e0</span> <span class="o">=</span> <span class="n">e1</span><span class="p">;</span> <span class="c1">// e0引用由e1管理的对象</span>
</code></pre></div></div>

<h2 id="面向对象">面向对象</h2>

<h3 id="结构体和类">结构体和类</h3>

<p>在C++中，结构体（Structs）和类（Classes）非常相似，主要区别在于成员的默认访问修饰符：结构体默认为public，而类默认为private。</p>

<p>选择使用结构体还是类通常取决于是否需要对成员数据施加特定的约束或规则（Invariants）。如果成员数据需要满足某些条件，使用类是更好的选择。</p>

<p>以日期容器为例，日期的整数值需要满足特定规则：必须在1到31之间。由于这个约束，更适合使用类来实现。在C++中，这种约束通常被称为不变式（Invariants）。</p>

<h3 id="访问修饰符">访问修饰符</h3>

<p>在C++中，类的成员（包括数据成员和成员函数）有三种访问修饰符（Access Modifiers）：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">private</code>：仅同一个类的成员函数或友元类（friend class）可以访问。</li>
  <li><code class="language-plaintext highlighter-rouge">protected</code>：除了<code class="language-plaintext highlighter-rouge">private</code>的权限外，子类也可以访问。</li>
  <li><code class="language-plaintext highlighter-rouge">public</code>：任何地方都可以访问。</li>
</ul>

<p>类的默认的访问修饰符是<code class="language-plaintext highlighter-rouge">private</code>。</p>

<p>通过关键字  <code class="language-plaintext highlighter-rouge">friend</code> ，我们可以访问类的 <code class="language-plaintext highlighter-rouge">private</code> 或  <code class="language-plaintext highlighter-rouge">protected</code> 成员，如下面的例子所示</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">a_plus_one</span><span class="p">(</span><span class="n">Foo</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="运算符的读法">运算符的读法</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">*x</code>：pointed by x（由x指向的）</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;x</code>：address of x（x的地址）</li>
  <li><code class="language-plaintext highlighter-rouge">x.y</code>：member y of object x（对象x的成员y）</li>
  <li><code class="language-plaintext highlighter-rouge">(*x).y</code>：member y of object pointed by x（由x指向的对象的成员y）</li>
  <li><code class="language-plaintext highlighter-rouge">x-&gt;y</code>：等价于<code class="language-plaintext highlighter-rouge">(*x).y</code></li>
  <li><code class="language-plaintext highlighter-rouge">x[0]</code>：first object pointed by x（由x指向的第一个对象）</li>
  <li><code class="language-plaintext highlighter-rouge">x[1]</code>：second object pointed by x（由x指向的第二个对象）</li>
  <li><code class="language-plaintext highlighter-rouge">x[n]</code>：$n+1$th object pointed by x（由x指向的第$n+1$个对象）</li>
</ul>

<h3 id="构造函数">构造函数</h3>

<ul>
  <li>构造函数的声明格式为<code class="language-plaintext highlighter-rouge">ClassName::ClassName</code>。</li>
  <li>构造函数没有返回值，也不用声明<code class="language-plaintext highlighter-rouge">void</code>。</li>
  <li>构造函数可以被重载（Overloading）。</li>
  <li>类似于在Python中的 <code class="language-plaintext highlighter-rouge">__init__</code> 方法。</li>
</ul>

<p>现代C++推荐使用<strong>初始化列表（Initialization List）</strong>：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Foo</span> <span class="n">f</span><span class="p">{</span><span class="n">arg_1</span><span class="p">,</span> <span class="n">arg_2</span><span class="p">};</span>
</code></pre></div></div>

<p>而不是传统的：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Foo</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg_1</span><span class="p">,</span> <span class="n">arg_2</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="析构函数">析构函数</h3>

<ul>
  <li>拥有资源的类应该有一个<strong>析构函数（Destructor）</strong>。</li>
  <li>在Python中，相当于<code class="language-plaintext highlighter-rouge">__del__</code>方法。</li>
  <li>析构函数的声明格式为<code class="language-plaintext highlighter-rouge">ClassName::~ClassName</code>。</li>
</ul>

<p>在C++中，拥有资源的类（Resource-owning class）通常指的是类内部管理着一些需要手动释放的资源，这些资源通常是在堆（heap）上分配的内存（通常通过 <code class="language-plaintext highlighter-rouge">new</code> 或 <code class="language-plaintext highlighter-rouge">new[]</code> 运算符），或者其他需要显式释放的系统资源（如文件句柄、网络连接等）。</p>

<p>例如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ResourceOwner</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">ResourceOwner</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">ResourceOwner</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在这个例子中，<code class="language-plaintext highlighter-rouge">ResourceOwner</code> 类是一个”拥有资源的类”，因为它在堆上分配了一个整数数组，并在其析构函数中释放了这个资源。</p>

<h3 id="运算符重载">运算符重载</h3>

<p>运算符重载（Operator Overloading）的格式：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ReturnType</span> <span class="n">ClassName</span><span class="o">::</span><span class="k">operator</span> <span class="n">Symbol</span> <span class="p">(</span><span class="n">ParameterType</span> <span class="n">parameterName</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="静态成员">静态成员</h3>

<ul>
  <li>静态成员不依赖于具体的对象。</li>
  <li>静态成员必须在类定义之外进行定义。</li>
</ul>

<p>静态成员（Static Members）在C++中有多种使用场景：</p>

<p><strong>共享数据</strong>：当你希望类的所有实例共享同一份数据时，可以使用静态成员变量。例如，你可能想要跟踪一个类的所有实例数量。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">instanceCount</span><span class="p">;</span>
    <span class="n">MyClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">instanceCount</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">instanceCount</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">instanceCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>工具函数</strong>：当一个函数与类有关，但不依赖于类的实例状态时，可以将其声明为静态成员函数。这样的函数只能访问静态成员变量。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MathUtils</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">double</span> <span class="n">squareRoot</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>单例模式</strong>：静态成员常用于实现单例模式，确保一个类只有一个实例。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Singleton</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">instance</span><span class="p">;</span>
    <span class="n">Singleton</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="nf">getInstance</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>常量</strong>：当你需要一个与类关联的常量，但不希望为每个实例都存储一份时，可以使用静态成员。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Circle</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">PI</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">Circle</span><span class="o">::</span><span class="n">PI</span> <span class="o">=</span> <span class="mf">3.14159</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>缓存和优化</strong>：静态成员可以用于存储那些计算代价高昂但不频繁变化的数据，以提高程序性能。</p>

<h3 id="继承">继承</h3>

<ul>
  <li>子类（Derived Class）继承父类（Base Class）的格式：<code class="language-plaintext highlighter-rouge">class DerivedClass: AccessSpecifier BaseClass</code>。</li>
  <li>C++支持多重继承。</li>
</ul>

<p>示例</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="nl">protected:</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
    <span class="c1">// x is public</span>
    <span class="c1">// y is protected</span>
    <span class="c1">// z is not accessible</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="虚函数">虚函数</h3>

<p>在C++中，虚函数（Virtual Functions）主要用于实现多态性（Polymorphism），特别是运行时多态性（Runtime Polymorphism）。以下是一些常见的应用场景：</p>

<p><strong>接口抽象</strong>：当我们有多个派生类（Derived Classes），并且它们共享相同的<strong>基类接口</strong>时，可以使用虚函数。这允许我们通过<strong>基类指针</strong>或<strong>引用</strong>来操作不同的<strong>派生类对象</strong>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Default Implementation */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* Circle-specific Implementation */</span> <span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div>

<p><strong>动态分发</strong>：虚函数允许在运行时确定应调用哪个派生类的方法，而不是在编译时。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shape</span><span class="o">*</span> <span class="n">shape</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Circle</span><span class="p">();</span>
<span class="n">shape</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span>  <span class="c1">// Calls Circle::draw() at runtime</span>
</code></pre></div></div>

<p><strong>模板方法模式</strong>：在这种设计模式中，基类定义了一个算法的框架，而将一些步骤的具体实现延迟到派生类中。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Algorithm</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">step1</span><span class="p">();</span>
        <span class="n">step2</span><span class="p">();</span>  <span class="c1">// Virtual function</span>
        <span class="n">step3</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">step2</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Pure virtual function</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>资源释放</strong>：虚析构函数（Virtual Destructor）用于确保当删除基类指针时，派生类的析构函数也会被调用，从而正确地释放资源。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Resource cleanup */</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="修饰符">修饰符</h2>

<p>在使用 C++ 语言编写程序的时候，我们可以通过<strong>修饰符</strong>，来指定变量、函数或类的一些特性或行为。这些修饰符可以影响编译器如何解释代码，或者如何生成机器代码。</p>

<h3 id="修饰符类别">修饰符类别</h3>

<p>修饰符包括下面的种类，</p>

<ul>
  <li>存储类说明符：用于描述变量或函数的存储期限、可见性和生命周期，如
    <ul>
      <li><code class="language-plaintext highlighter-rouge">static</code>：用于指定变量、函数或类成员的存储期限和可见性，使其在程序的整个生命周期内保持状态。</li>
      <li><code class="language-plaintext highlighter-rouge">auto</code>: 用于自动推断变量的类型。这在 C++11 及以后的版本中特别有用。</li>
      <li><code class="language-plaintext highlighter-rouge">register</code>: 这个关键字用于建议编译器将变量存储在寄存器中以加速访问，但现代编译器通常会自动进行这种优化，所以这个关键字现在基本上是废弃的。</li>
      <li><code class="language-plaintext highlighter-rouge">extern</code>：用于声明一个变量或函数是在其他文件中定义的。</li>
      <li><code class="language-plaintext highlighter-rouge">thread_local</code>：C++11 引入，用于指定一个变量是每个线程独有的。</li>
    </ul>
  </li>
  <li>类型限定符：用于描述变量的类型属性，如
    <ul>
      <li><code class="language-plaintext highlighter-rouge">const</code>：用于声明<strong>变量</strong>或<strong>对象</strong>的<strong>状态</strong>不可更改。</li>
      <li><code class="language-plaintext highlighter-rouge">volatile</code>：用于告诉编译器不要优化与该变量有关的代码。这通常用于多线程或硬件交互的情况。</li>
      <li><code class="language-plaintext highlighter-rouge">mutable</code>: 在一个 <code class="language-plaintext highlighter-rouge">const</code> 成员函数中，<code class="language-plaintext highlighter-rouge">mutable</code> 关键字允许你修改成员变量。</li>
    </ul>
  </li>
  <li>函数修饰符： 用于描述成员函数的特性，如
    <ul>
      <li><code class="language-plaintext highlighter-rouge">inline</code>：用于建议编译器内联一个函数，即将函数调用替换为函数体。</li>
      <li><code class="language-plaintext highlighter-rouge">virtual</code>：用于声明一个函数为虚函数，允许在派生类中重写它。</li>
      <li><code class="language-plaintext highlighter-rouge">override</code>：用于明确指出派生类中的函数是重写基类中的虚函数。</li>
      <li><code class="language-plaintext highlighter-rouge">final</code>：阻止进一步的继承（如果用于类）或重写（如果用于虚函数）。</li>
      <li><code class="language-plaintext highlighter-rouge">explicit</code>：用于阻止不应发生的隐式类型转换。</li>
    </ul>
  </li>
</ul>

<h3 id="static"><code class="language-plaintext highlighter-rouge">static</code></h3>

<p>在 C++ 中，<code class="language-plaintext highlighter-rouge">static</code> 关键字有多个使用场景，具体取决于它出现的上下文。以下是主要的使用场景：</p>

<p><strong>静态局部变量</strong>：在函数内部，<code class="language-plaintext highlighter-rouge">static</code> 用于声明静态局部变量。这些变量在第一次函数调用时初始化，并在程序的整个生命周期内保持其值，如下面的代码所示：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">counter</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>静态成员变量</strong>：在类中，<code class="language-plaintext highlighter-rouge">static</code> 用于声明静态成员变量。这些变量属于类本身，而不是类的任何特定实例，如下面的代码所示：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">staticVar</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">staticVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 初始化</span>
</code></pre></div></div>

<p><strong>静态成员函数</strong>：在类中，<code class="language-plaintext highlighter-rouge">static</code> 也可以用于声明静态成员函数。这些函数可以直接通过类名调用，而<strong>不需要类的实例</strong>，如下面的代码所示：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">staticFunction</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>静态全局变量和函数（文件作用域）</strong>：在全局作用域中，<code class="language-plaintext highlighter-rouge">static</code> 限制变量或函数的可见性，使其只在定义它的文件内可见，如下面的代码所示：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: main.cpp</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">staticGlobalVar</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1">// 只在 main.cpp 内可见</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">staticGlobalFunction</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>静态类（匿名命名空间）</strong>：在 C++17 中，我们可以使用静态类（通常在匿名命名空间内）来限制类的可见性，如下面的代码所示：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">class</span> <span class="nc">StaticClass</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="const"><code class="language-plaintext highlighter-rouge">const</code></h3>

<p>在C++的面向对象编程中，<code class="language-plaintext highlighter-rouge">const</code> 主要用于增加类型安全和程序可读性，同时也有助于优化。其主要的功能如下，</p>

<ul>
  <li>不可变性：<code class="language-plaintext highlighter-rouge">const</code> 用于声明<strong>变量</strong>或<strong>对象</strong>的<strong>状态</strong>不可更改。</li>
  <li>编译时检查：<code class="language-plaintext highlighter-rouge">const</code> 允许编译器在编译时进行安全检查。</li>
</ul>

<p>这个关键字的使用场景如下，</p>

<p><strong>成员函数</strong>：在成员函数后添加 <code class="language-plaintext highlighter-rouge">const</code> 关键字，表示该函数不会修改<strong>调用它的对象</strong>的状态。这样的函数称为 <code class="language-plaintext highlighter-rouge">const</code> 成员函数。示例如下</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">NonConstFunction</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Can modify object state */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">ConstFunction</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="cm">/* Cannot modify object state */</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>注意，即使在<code class="language-plaintext highlighter-rouge">const function</code>中，<code class="language-plaintext highlighter-rouge">mutable</code>修饰的成员变量也可以被修改。</p>

<p><strong>对象实例</strong>：用 <code class="language-plaintext highlighter-rouge">const</code>声明的<strong>对象实例</strong>不能调用非 <code class="language-plaintext highlighter-rouge">const</code> 成员函数。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">MyClass</span> <span class="n">obj</span><span class="p">;</span>
<span class="n">obj</span><span class="p">.</span><span class="n">NonConstFunction</span><span class="p">();</span>  <span class="c1">// Compilation error</span>
<span class="n">obj</span><span class="p">.</span><span class="n">ConstFunction</span><span class="p">();</span>     <span class="c1">// OK</span>
</code></pre></div></div>

<p><strong>对象实例</strong>：用 <code class="language-plaintext highlighter-rouge">const</code> 声明的对象实例不能调用非 const 成员函数。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">MyFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Cannot modify obj</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>返回值</strong>：返回 <code class="language-plaintext highlighter-rouge">const</code> 类型可以防止对函数返回值的非法修改。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">Modify</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* modify object */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">const</span> <span class="n">MyClass</span> <span class="nf">CreateObject</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MyClass</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyClass</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">CreateObject</span><span class="p">();</span>  <span class="c1">// OK</span>
    <span class="n">CreateObject</span><span class="p">().</span><span class="n">Modify</span><span class="p">();</span>       <span class="c1">// Compilation error</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>静态成员变量</strong>：类中的<strong>静态成员变量</strong>经常被声明为 <code class="language-plaintext highlighter-rouge">const</code>，以表示它们是不可变的。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">staticValue</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="inline"><code class="language-plaintext highlighter-rouge">inline</code></h3>

<p><code class="language-plaintext highlighter-rouge">inline</code> 关键字在 C++ 中有多个用途和考虑因素。</p>

<p><strong>性能优化</strong>：<code class="language-plaintext highlighter-rouge">inline</code> 的一个主要用途是性能优化。当函数被标记为 <code class="language-plaintext highlighter-rouge">inline</code>，编译器会尝试将函数的代码直接嵌入到每个调用点，从而减少函数调用的开销。然而，这只是一个给编译器的“建议”，对于复杂或较长的函数，编译器可能会忽略这个建议。</p>

<p><strong>避免重复定义</strong>：<code class="language-plaintext highlighter-rouge">inline</code> 还用于解决链接阶段的重复定义问题。这在模板函数和在头文件中定义的普通函数中尤为重要。如果一个函数（模板或普通函数）在头文件中定义，并且这个头文件被多个源文件包含，那么标记该函数为 <code class="language-plaintext highlighter-rouge">inline</code> 可以避免链接时的重复定义错误。例如：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// math_utils.h</span>
<span class="cp">#pragma once
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">square</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后在两个不同的源文件中：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main1.cpp</span>
<span class="cp">#include</span> <span class="cpf">"math_utils.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">square</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main2.cpp</span>
<span class="cp">#include</span> <span class="cpf">"math_utils.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">square</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在这种情况下，如果 <code class="language-plaintext highlighter-rouge">square</code> 函数没有被标记为 <code class="language-plaintext highlighter-rouge">inline</code>，链接器会发现两个相同的 <code class="language-plaintext highlighter-rouge">square&lt;int&gt;</code> 函数定义，从而导致重复定义错误。使用 <code class="language-plaintext highlighter-rouge">inline</code> 可以解决这个问题。</p>

<p><strong>头文件中的函数</strong>：虽然通常不推荐在头文件中定义普通函数，但在某些特定场景（如小型工具函数或模板函数）下，这是可接受的。在这种情况下，<code class="language-plaintext highlighter-rouge">inline</code> 是必要的，以确保多个编译单元中的函数定义在链接阶段被视为同一实例。</p>

<p><strong>编译器自动内联</strong>：值得注意的是，现代编译器通常会自动内联一些小函数，即使没有明确地使用 <code class="language-plaintext highlighter-rouge">inline</code> 关键字。但依赖编译器的自动内联并不能解决重复定义的问题。</p>

<p>综合来说，<code class="language-plaintext highlighter-rouge">inline</code> 是一个多用途的关键字，用于性能优化和代码组织。它既可以作为编译器优化的建议，也可以作为避免链接时错误的工具。在使用 <code class="language-plaintext highlighter-rouge">inline</code> 时，应明确其目的，并根据具体情况权衡利弊。</p>

<h2 id="优化">优化</h2>

<h3 id="汇编代码">汇编代码</h3>

<p>通过 GCC 的 <code class="language-plaintext highlighter-rouge">-S</code> 编译选项，我们可以输出 C++ 代码对应的汇编代码，例如：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-S</span> <span class="nt">-g</span> <span class="nt">-O3</span> <span class="nt">-march</span><span class="o">=</span>native <span class="nt">-std</span><span class="o">=</span>c++17 src.cc
</code></pre></div></div>

<p>在网站 <a href="">Compiler Explorer</a> 中，我们可以轻松地查看 C++ 代码在经过不同的编译器选项之后，得到的汇编代码。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cfloat&gt;</span><span class="c1"> // for FLT_MAX</span><span class="cp">
</span>
<span class="kt">float</span> <span class="nf">find_min</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">arr1</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">arr2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">min_val</span> <span class="o">=</span> <span class="n">FLT_MAX</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">min_val</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">min_val</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">min_val</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">arr1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">arr2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">5.6</span><span class="p">,</span> <span class="mf">6.7</span><span class="p">,</span> <span class="mf">7.8</span><span class="p">,</span> <span class="mf">8.9</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr1</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="kt">float</span> <span class="n">min_val</span> <span class="o">=</span> <span class="n">find_min</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The minimum value is: "</span> <span class="o">&lt;&lt;</span> <span class="n">min_val</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于函数 <code class="language-plaintext highlighter-rouge">find_min</code>，其对应的汇编代码是</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find_min(float*, float*, int):
        testl   %edx, %edx
        jle     .L5
        movslq  %edx, %rdx
        vmovss  .LC0(%rip), %xmm1
        salq    $2, %rdx
        xorl    %eax, %eax
.L4:
        vmovss  (%rdi,%rax), %xmm0
        vaddss  (%rsi,%rax), %xmm0, %xmm0
        addq    $4, %rax
        vminss  %xmm1, %xmm0, %xmm1
        cmpq    %rax, %rdx
        jne     .L4
        vmovaps %xmm1, %xmm0
        ret
.L5:
        vmovss  .LC0(%rip), %xmm1
        vmovaps %xmm1, %xmm0
        ret
</code></pre></div></div>

<p>其中的一些变量解释如下，</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">%edx</code>: 存储整数参数（<code class="language-plaintext highlighter-rouge">int n</code>）。</li>
  <li><code class="language-plaintext highlighter-rouge">%rdi</code>, <code class="language-plaintext highlighter-rouge">%rsi</code>: 存储指向浮点数组的指针（<code class="language-plaintext highlighter-rouge">float* arr1</code>, <code class="language-plaintext highlighter-rouge">float* arr2</code>）。</li>
  <li><code class="language-plaintext highlighter-rouge">%xmm0</code>, <code class="language-plaintext highlighter-rouge">%xmm1</code>: 用于浮点运算的SSE寄存器。</li>
  <li><code class="language-plaintext highlighter-rouge">%rax</code>, <code class="language-plaintext highlighter-rouge">%rdx</code>: 通用寄存器。</li>
</ul>

<p>整个代码执行了下面的操作：</p>

<ol>
  <li><strong>初始化和边缘情况处理</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">testl %edx, %edx</code>: 检查<code class="language-plaintext highlighter-rouge">n</code>是否为零或负数。</li>
      <li><code class="language-plaintext highlighter-rouge">jle .L5</code>: 如果<code class="language-plaintext highlighter-rouge">n</code>为零或负数，跳转到<code class="language-plaintext highlighter-rouge">.L5</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">movslq %edx, %rdx</code>: 将<code class="language-plaintext highlighter-rouge">n</code>移动到<code class="language-plaintext highlighter-rouge">%rdx</code>并符号扩展。</li>
      <li><code class="language-plaintext highlighter-rouge">vmovss .LC0(%rip), %xmm1</code>: 用<code class="language-plaintext highlighter-rouge">FLT_MAX</code>初始化<code class="language-plaintext highlighter-rouge">%xmm1</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">salq $2, %rdx</code>: 将<code class="language-plaintext highlighter-rouge">%rdx</code>乘以4（字节偏移）。</li>
      <li><code class="language-plaintext highlighter-rouge">xorl %eax, %eax</code>: 将<code class="language-plaintext highlighter-rouge">%eax</code>设置为0（循环计数器）。</li>
    </ul>
  </li>
  <li><strong>循环操作（.L4）</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">vmovss (%rdi,%rax), %xmm0</code>: 将<code class="language-plaintext highlighter-rouge">arr1[i]</code>加载到<code class="language-plaintext highlighter-rouge">%xmm0</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">vaddss (%rsi,%rax), %xmm0, %xmm0</code>: 将<code class="language-plaintext highlighter-rouge">arr2[i]</code>添加到<code class="language-plaintext highlighter-rouge">%xmm0</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">addq $4, %rax</code>: 将<code class="language-plaintext highlighter-rouge">%rax</code>增加4（下一个浮点数）。</li>
      <li><code class="language-plaintext highlighter-rouge">vminss %xmm1, %xmm0, %xmm1</code>: 计算最小值。</li>
      <li><code class="language-plaintext highlighter-rouge">cmpq %rax, %rdx</code>: 比较<code class="language-plaintext highlighter-rouge">%rax</code>和<code class="language-plaintext highlighter-rouge">%rdx</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">jne .L4</code>: 如果不相等，跳回<code class="language-plaintext highlighter-rouge">.L4</code>。</li>
    </ul>
  </li>
  <li><strong>返回值</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">vmovaps %xmm1, %xmm0</code>: 将结果移动到<code class="language-plaintext highlighter-rouge">%xmm0</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">ret</code>: 返回。</li>
    </ul>
  </li>
  <li><strong>边缘情况返回（.L5）</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">vmovss .LC0(%rip), %xmm1</code>: 用<code class="language-plaintext highlighter-rouge">FLT_MAX</code>初始化<code class="language-plaintext highlighter-rouge">%xmm1</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">vmovaps %xmm1, %xmm0</code>: 将结果移动到<code class="language-plaintext highlighter-rouge">%xmm0</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">ret</code>: 返回。</li>
    </ul>
  </li>
</ol>

<h3 id="线性访问">线性访问</h3>

<ul>
  <li>硬件预取（Hardware Prefetching）机制会自动预加载连续的内存地址，减少从主内存到缓存的数据传输。</li>
  <li>非线性访问可能导致缓存失效（Cache Miss），需要重新从主内存加载数据，这通常比从缓存加载要慢得多。</li>
  <li>线性访问数组元素可以显著提高缓存利用率，从而提高程序性能。</li>
</ul>

<p><strong>优化策略</strong></p>

<ol>
  <li>数据重组：如果可能，重新组织数据以便能够进行线性访问。</li>
  <li>循环重排：调整嵌套循环的顺序，使内层循环能够线性访问数据。</li>
</ol>

<p><strong>代码示例</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 线性访问</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 线性访问 array[i][j]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 非线性访问</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 非线性访问 array[j][i]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="其他话题">其他话题</h2>

<h3 id="最令人困惑的解析">最令人困惑的解析</h3>

<p>『最令人困惑的解析』这个术语是由 Scott Meyers 在他的书 “Effective STL” 中普及。</p>

<p>它指的是当<strong>编译器</strong>必须在将一个<strong>语句</strong>解释为</p>

<ul>
  <li>函数声明, 或者</li>
  <li>变量声明</li>
</ul>

<p>二者之一时，出现的语法模糊性。它是 C++ 语言中的一个特点，对程序员来说可能是一个混淆的源头。</p>

<p>让我们看一个此模糊性的经典示例：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">B</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">B</span> <span class="n">b</span><span class="p">(</span><span class="n">A</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>你可能会期望 <code class="language-plaintext highlighter-rouge">B b(A());</code> 定义了一个类型为 <code class="language-plaintext highlighter-rouge">B</code> 的对象 <code class="language-plaintext highlighter-rouge">b</code>，并用类型为 <code class="language-plaintext highlighter-rouge">A</code> 的匿名对象初始化它（即调用构造函数 <code class="language-plaintext highlighter-rouge">B(A a)</code>）。</p>

<p>但是，C++ 对此有不同的解释：它将这一行解释为声明一个名为 <code class="language-plaintext highlighter-rouge">b</code> 的函数，该函数接受一个函数指针（没有参数并返回一个 <code class="language-plaintext highlighter-rouge">A</code>）并返回一个 <code class="language-plaintext highlighter-rouge">B</code>。</p>

<p>问题出现在括号上。C++ 语法的构造是这样的，当它看到 <code class="language-plaintext highlighter-rouge">B b(A());</code> 时，它更倾向于将其解释为函数声明，而不是带有构造函数调用的变量声明。这种行为与编译器以尽可能通用的方式解析语句的偏好是一致的。</p>

<p>要消除这种模糊性，有几种方法：</p>

<ol>
  <li><strong>使用额外的括号集：</strong>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">B</span> <span class="nf">b</span><span class="p">((</span><span class="n">A</span><span class="p">()));</span>
</code></pre></div>    </div>
    <p>通过这样做，你明确表示你不是在声明一个函数。</p>
  </li>
  <li><strong>使用统一的初始化（C++11 及以后版本）：</strong>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">B</span> <span class="n">b</span><span class="p">{</span><span class="n">A</span><span class="p">()};</span>
</code></pre></div>    </div>
    <p>随着 C++11 通过大括号引入的统一初始化，这种模糊性得到了解决，因为函数声明不使用大括号。</p>
  </li>
  <li><strong>创建一个命名的 <code class="language-plaintext highlighter-rouge">A</code> 实例：</strong>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="n">B</span> <span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>随着 C++11 引入的『统一初始化』语法，这个问题已经被解决。但理解它可以帮助解读旧的 C++ 代码，或理解 C++ 语法的一些复杂之处。</p>

<h3 id="头文件里放什么">头文件里放什么</h3>

<p>一个 C++ 的项目里 通常有很多 头文件 (<code class="language-plaintext highlighter-rouge">.h</code>, <code class="language-plaintext highlighter-rouge">.hpp</code> 甚至 <code class="language-plaintext highlighter-rouge">.tpp</code>) 和 代码文件 (<code class="language-plaintext highlighter-rouge">.cpp</code>)。什么东西应该被放进 头文件 (head file) 而什么应该被放进 代码文件 (code file) 呢？</p>

<p>我在 Stackoverflow 上看到了一个 <a href="https://stackoverflow.com/a/1945866">很好的答案</a>。简而言之，</p>

<ul>
  <li>在头文件里，我们放入「很多文件 共同需要的 信息」，即 <strong>抽象定义</strong>。</li>
  <li>在代码文件里，我们放入「只被这个文件需要的 信息」，即 <strong>具体实现</strong>。</li>
</ul>

<h3 id="stdmap">std::map</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">std::map</code> 里，每个「元素的类型」是 <code class="language-plaintext highlighter-rouge">pair</code>，<code class="language-plaintext highlighter-rouge">pair.first</code> = 键；<code class="language-plaintext highlighter-rouge">pair.second</code> = 值。</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">std::map</code> 可以用</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">item</span> <span class="o">:</span> <span class="n">map_instance</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">;}</span>
</code></pre></div></div>
<p>的格式迭代。其中，<code class="language-plaintext highlighter-rouge">item</code> 的类型是 <a href="https://en.cppreference.com/w/cpp/utility/pair"><code class="language-plaintext highlighter-rouge">pair</code></a>。我们可以用 <code class="language-plaintext highlighter-rouge">item.first</code> 获取 键；用 <code class="language-plaintext highlighter-rouge">item.second</code> 获取 值。一个完整的例子如下</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"apple"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"orange"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">item</span> <span class="o">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="vim-配置">Vim 配置</h3>

<p>我编写 C++ 代码的时候，习惯使用 vim 作为编辑器，搭配插件 <a href="https://github.com/dense-analysis/ale">ale</a> 和 <a href="https://github.com/ycm-core/YouCompleteMe">YouCompleteMe</a>。前者是作用是 检查代码语法，后者的作用是 代码的自动补全。在插件 <a href="https://github.com/dense-analysis/ale">ale</a> 进行 语法检查 的时候，我们需要「告诉」vim 我们的编译选项。由于 不同项目使用的 编译选项 不同，所以我倾向于 在不同项目下 使用不同的 vim 配置。具体的做法如下。</p>

<p>首先，向系统的 VIM 配置文件 (<code class="language-plaintext highlighter-rouge">vimrc</code>) 添加下面两行代码。大部分 Linux 系统下，这个文件处于 <code class="language-plaintext highlighter-rouge">$HOME/.vimrc</code> 或者 <code class="language-plaintext highlighter-rouge">$HOME/.vim/vimrc</code>。</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="nb">exrc</span>
<span class="k">set</span> <span class="nb">secure</span>
</code></pre></div></div>

<p>上面的 两行代码 能够让 vim 读取「当前的工作文件夹」下的 配置文件。其次，在 C++ 项目的文件夹（即，我们的工作文件夹）里，创建一个 命名为 <code class="language-plaintext highlighter-rouge">.vimrc</code> 的文件，加入下面的代码。</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">g:ale_linters</span> <span class="p">=</span> <span class="p">{</span><span class="s1">'cpp'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'clang'</span><span class="p">]}</span>  " use clang <span class="k">compiler</span>
<span class="k">let</span> cpp_flags <span class="p">=</span> <span class="s1">'-std=c++11 -Wall '</span>  " <span class="k">c</span><span class="p">++</span> standard &amp; show <span class="k">all</span> warnings
<span class="k">let</span> <span class="nv">g:ale_cpp_clang_options</span> <span class="p">=</span> cpp_flags  " <span class="k">set</span> the flag <span class="k">for</span> linting
</code></pre></div></div>

<p>我们可以在 <code class="language-plaintext highlighter-rouge">cpp_flags</code> 里加入更多的参数，来满足项目的需要。下面的 <code class="language-plaintext highlighter-rouge">.vimrc</code> 文件是我在使用 <code class="language-plaintext highlighter-rouge">Eigen</code> 库时使用的参数。</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">g:ale_linters</span> <span class="p">=</span> <span class="p">{</span><span class="s1">'cpp'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'clang'</span><span class="p">]}</span>  " use clang <span class="k">compiler</span>
<span class="k">let</span> cpp_flags <span class="p">=</span> <span class="s1">'-std=c++11 -Wall '</span>  " <span class="k">c</span><span class="p">++</span> standard &amp; show <span class="k">all</span> warnings
<span class="k">let</span> cpp_flags <span class="p">=</span> cpp_flags <span class="p">.</span> <span class="s1">'-I/usr/local/include/eigen3'</span> <span class="p">.</span> <span class="s1">' '</span>  " <span class="k">for</span> eigen
<span class="k">let</span> cpp_flags <span class="p">=</span> cpp_flags <span class="p">.</span> <span class="s1">'-Wno-unknown-warning-option'</span> <span class="p">.</span> <span class="s1">' '</span>  " supress eigen warnings
<span class="k">let</span> <span class="nv">g:ale_cpp_clang_options</span> <span class="p">=</span> cpp_flags  " <span class="k">set</span> the flag <span class="k">for</span> linting
</code></pre></div></div>


</div>



  </body>

</html>
